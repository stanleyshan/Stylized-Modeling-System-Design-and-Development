#include "qopenmeshobject.h"

#include <vector>
#include <OpenMesh/Core/IO/MeshIO.hh>
#include <QDir>

MeshData* OpenMeshObject::loadMesh(QString objFilePath)
{
    MeshData* mesh_data = NULL;
    BaseMesh mesh;

    mesh.request_vertex_normals();
    mesh.request_face_normals();
    mesh.request_vertex_texcoords2D();

    OpenMesh::IO::Options opt;
    opt += OpenMesh::IO::Options::VertexTexCoord;
    if ( !OpenMesh::IO::read_mesh(mesh, objFilePath.toStdString(), opt) )
    {
        qDebug() << "Load Failed: " << objFilePath;
        return NULL;
    }
    else
    {
        mesh_data = new MeshData;
    }

    if ( !opt.check( OpenMesh::IO::Options::VertexNormal ) )
        mesh.update_normals();

    QVector<CommonShaderData> datas;
    QVector<GLushort> indices;
    for(BaseMesh::VertexIter v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it)
    {
        CommonShaderData shaderData;
        BaseMesh::Point point = mesh.point(*v_it);
        shaderData.position[0] = point[0];
        shaderData.position[1] = point[1];
        shaderData.position[2] = point[2];
        BaseMesh::Normal normal = mesh.normal(*v_it);
        shaderData.normal[0] = normal[0];
        shaderData.normal[1] = normal[1];
        shaderData.normal[2] = normal[2];
        BaseMesh::TexCoord2D texCoord = mesh.texcoord2D(*v_it);
        shaderData.texcoord[0] = texCoord[0];
        shaderData.texcoord[1] = texCoord[1];
        datas.push_back(shaderData);
    }
    for ( BaseMesh::FaceIter f_it = mesh.faces_begin(); f_it != mesh.faces_end(); ++f_it )
    {
        for ( BaseMesh::FaceVertexIter fv_it = mesh.fv_iter(*f_it); fv_it.is_valid(); ++fv_it )
        {
            indices.push_back(fv_it->idx());
        }
    }

    mesh_data->datas = datas;
    mesh_data->indices = indices;

    return mesh_data;
}

void OpenMeshObject::resetRenderData()
{
    MeshData* mesh_data;
    if(!meshRenderer->mVec_load_costume[meshRenderer->main_costume_idx][meshRenderer->sub_constume_idx])
    {
        meshRenderer->mVec_load_costume[meshRenderer->main_costume_idx][meshRenderer->sub_constume_idx] = true;
        // Not the clothset
        if(meshRenderer->main_costume_idx < 6)
        {
            QString filePath = meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx][meshRenderer->sub_constume_idx];

            mesh_data = loadMesh(m_appFileDirectory+filePath);

            switch(meshRenderer->main_costume_idx)
            {
                // load hat model
                case 0:
                    meshRenderer->mVec_hatModel_data[meshRenderer->sub_constume_idx] = mesh_data->datas;
                    meshRenderer->mVec_hatModel_indices[meshRenderer->sub_constume_idx] = mesh_data->indices;
                    break;
                // load hair model
                case 1:
                    meshRenderer->mVec_hairModel_data[meshRenderer->sub_constume_idx] = mesh_data->datas;
                    meshRenderer->mVec_hairModel_indices[meshRenderer->sub_constume_idx] = mesh_data->indices;
                    break;
                // load cloth model
                case 2:
                    meshRenderer->mVec_clothModel_data[meshRenderer->sub_constume_idx] = mesh_data->datas;
                    meshRenderer->mVec_clothModel_indices[meshRenderer->sub_constume_idx] = mesh_data->indices;
                    break;
                // load pants model
                case 3:
                    meshRenderer->mVec_pantsModel_data[meshRenderer->sub_constume_idx] = mesh_data->datas;
                    meshRenderer->mVec_pantsModel_indices[meshRenderer->sub_constume_idx] = mesh_data->indices;
                    break;
                //load shoes model
                case 4:
                    meshRenderer->mVec_shoesModel_data[meshRenderer->sub_constume_idx] = mesh_data->datas;
                    meshRenderer->mVec_shoesModel_indices[meshRenderer->sub_constume_idx] = mesh_data->indices;
                    break;
                //load part model
                case 5:
                    meshRenderer->mVec_partModel_data[meshRenderer->sub_constume_idx] = mesh_data->datas;
                    meshRenderer->mVec_partModel_indices[meshRenderer->sub_constume_idx] = mesh_data->indices;
                    break;
                default:
                    break;
            }
        }
        // The clothset
        else
        {
            QVector<QVector<CommonShaderData>> tmp_model_data;
            QVector<QVector<GLushort>> tmp_model_indices;
            switch(meshRenderer->sub_constume_idx)
            {
                // Ironman
                case 0:
                    for(int i=0; i<meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx].length(); i++)
                    {
                        QString filePath = meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx][i];

                        mesh_data = loadMesh(m_appFileDirectory+filePath);

                        tmp_model_data.push_back(mesh_data->datas);
                        tmp_model_indices.push_back(mesh_data->indices);
                    }
                    break;
                // Luffy
                case 1:
                    for(int i=0; i<meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx + meshRenderer->sub_constume_idx].length(); i++)
                    {
                        QString filePath = meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx + meshRenderer->sub_constume_idx][i];

                        mesh_data = loadMesh(m_appFileDirectory+filePath);

                        tmp_model_data.push_back(mesh_data->datas);
                        tmp_model_indices.push_back(mesh_data->indices);
                    }
                    break;
                // Minion
                case 2:
                    for(int i=0; i<meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx + meshRenderer->sub_constume_idx].length(); i++)
                    {
                        QString filePath = meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx + meshRenderer->sub_constume_idx][i];

                        mesh_data = loadMesh(m_appFileDirectory+filePath);

                        tmp_model_data.push_back(mesh_data->datas);
                        tmp_model_indices.push_back(mesh_data->indices);
                    }
                    break;
                // Chopper
                case 3:
                    for(int i=0; i<meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx + meshRenderer->sub_constume_idx].length(); i++)
                    {
                        QString filePath = meshRenderer->mVec_Model_filePath[meshRenderer->main_costume_idx + meshRenderer->sub_constume_idx][i];

                        mesh_data = loadMesh(m_appFileDirectory+filePath);

                        tmp_model_data.push_back(mesh_data->datas);
                        tmp_model_indices.push_back(mesh_data->indices);
                    }
                    break;
                default:
                    break;
            }
            meshRenderer->mVec_clothsetModel_data[meshRenderer->sub_constume_idx] = tmp_model_data;
            meshRenderer->mVec_clothsetModel_indices[meshRenderer->sub_constume_idx] = tmp_model_indices;
        }
    }
    // Hat
    if(meshRenderer->main_costume_idx == 0)
    {
        for(int i=0; i<meshRenderer->mVec_costume[1].length(); i++)
            meshRenderer->mVec_costume[1][i] = false;

        for(int i=0; i<meshRenderer->mVec_costume[6].length(); i++)
            meshRenderer->mVec_costume[6][i] = false;
    }
    // Hair
    else if(meshRenderer->main_costume_idx == 1)
    {
        for(int i=0; i<meshRenderer->mVec_costume[0].length(); i++)
            meshRenderer->mVec_costume[0][i] = false;

        for(int i=0; i<meshRenderer->mVec_costume[6].length(); i++)
            meshRenderer->mVec_costume[6][i] = false;
    }
    // Short
    else if(meshRenderer->main_costume_idx == 2)
    {
        meshRenderer->mVec_costume[3][0] = false;
        for(int i=0; i<meshRenderer->mVec_costume[6].length(); i++)
            meshRenderer->mVec_costume[6][i] = false;
    }
    // Pants
    else if(meshRenderer->main_costume_idx == 3)
    {
        meshRenderer->mVec_costume[2][0] = false;
        for(int i=0; i<meshRenderer->mVec_costume[6].length(); i++)
            meshRenderer->mVec_costume[6][i] = false;
    }
    // Cloth set
    else if(meshRenderer->main_costume_idx == 6)
    {
        for(int i=0; i<meshRenderer->main_costume_idx-1; i++)
            for(int j=0; j<meshRenderer->mVec_costume[meshRenderer->main_costume_idx-1].length(); j++)
                meshRenderer->mVec_costume[i][j] = false;
    }

    for(int i=0; i<meshRenderer->mVec_costume[meshRenderer->main_costume_idx].length(); i++)
    {
        if(i == meshRenderer->sub_constume_idx)
            meshRenderer->mVec_costume[meshRenderer->main_costume_idx][i] = true;
        else
            meshRenderer->mVec_costume[meshRenderer->main_costume_idx][i] = false;
    }
}

void OpenMeshObject::LoadMesh(QString objFilePath, bool isRender)
{
    mesh.request_vertex_normals();
    mesh.request_face_normals();

    OpenMesh::IO::Options opt;
    if ( !OpenMesh::IO::read_mesh(mesh, objFilePath.toStdString(), opt) )
    {
        qDebug() << "Load Failed: " << objFilePath;
        return;
    }

    if ( !opt.check( OpenMesh::IO::Options::VertexNormal ) )
        mesh.update_normals();

    meshRenderer = new MeshRenderer();
    if(isRender)
    {
        meshRenderer->initFaceGeometry(m_expFHandle, b_Mapping, VertexUVProp, FaceMask);
        meshRenderer->initMeshGeometry(mesh);
    }
}

void OpenMeshObject::SaveMesh( BaseMesh mesh )
{
    OpenMesh::IO::Options opt1;
    opt1 += OpenMesh::IO::Options::VertexNormal;
    QString output = m_appFileDirectory+"/modelFiles/deformModel.obj";
    if(!OpenMesh::IO::write_mesh(mesh, output.toStdString(), opt1))
    {
        qDebug() << "Save Failed: " << output;
    }
}

OpenMeshObject::OpenMeshObject(QString objFilePath) :
    meshRenderer(0),
    m_imagePath(Plugin::m_imagePath),
    m_featurePos(Plugin::m_featurePos),
    m_appFileDirectory(Plugin::m_appFileDirectory)
{
    mesh.request_vertex_normals();
    mesh.request_face_normals();
    mesh.request_vertex_texcoords2D();
    mesh.request_halfedge_texcoords2D();

    OpenMesh::IO::Options opt;
    opt += OpenMesh::IO::Options::FaceTexCoord;
    if ( !OpenMesh::IO::read_mesh(mesh, objFilePath.toStdString(), opt) )
    {
        qDebug() << "Load Failed: " << objFilePath;
        return;
    }

    if ( !opt.check( OpenMesh::IO::Options::VertexNormal ) )
        mesh.update_normals();

    // Deform
    isDeform = true;
    deform_times = 0;
    if(isDeform)
    {
        if(deform_times<5)
        {
            for( int i = 1; i<5; i++ )
            {
                if(i != 3)
                {
                    deform_times = i;
                    InitData();
                    CalculateMoveFeatures();
                    InitMatrix();
                    Deform();
                }
            }
            Update_control_points();
            // imageSize
            QImage tmp = QImage(m_imagePath).mirrored();
            int imageSize;
            if(tmp.width()>tmp.height())
            {
                imageSize = tmp.width();
            }
            else
            {
                imageSize = tmp.height();
            }
            // Exponential Maps (Face texture)
            ExpMap *expmap;
            expmap = new ExpMap();
            expmap->TextureMapping(mesh, control_pts, control_pts_VH, pos_facefeatures, imageSize);
            m_expFHandle = expmap->Get_expFH();
            b_Mapping = expmap->Get_Mapping();
            VertexUVProp = expmap->Get_uv();
            FaceMask = expmap->Get_mask();
        }
    }
    else
    {
        isDeform = true;
        deform_times = 0;
    }

    // SaveMesh
    SaveMesh(mesh);

    meshRenderer = new MeshRenderer();
    meshRenderer->initFaceGeometry(m_expFHandle, b_Mapping, VertexUVProp, FaceMask);
    meshRenderer->initMeshGeometry(mesh);
    meshRenderer->initMeshGeometry();
}

OpenMeshObject::~OpenMeshObject()
{
    if ( meshRenderer )
        delete meshRenderer;
}

void OpenMeshObject::PickVertex(QVector3D worldPos)
{
    Q_UNUSED(worldPos);
}

BaseMesh OpenMeshObject::MoveVector(BaseMesh mesh, double m_x, double m_y, double m_z)
{
    for (BaseMesh::VertexIter v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it)
    {
        BaseMesh::Point m_Vector(m_x, m_y, m_z);
        mesh.point(*v_it) += m_Vector;
    }
    return mesh;
}

void OpenMeshObject::Update_control_points()
{
    // update the control points position
    for (BaseMesh::VertexIter v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it)
    {
        for( size_t i = 0; i<control_pts_VH.size(); i++ )
        {
            if(control_pts_VH[i].idx() == v_it->idx())
            {
                control_pts_VH[i] = *v_it;
                control_pts[i] = mesh.point(*v_it);
            }
        }
    }
}

void OpenMeshObject::InitData()
{
    // Clear
    control_pts.clear();
    control_pts_VH.clear();
    // Set ROI Faces
    InitFHidx();
    // Set Control_pts (Vertex index)
    //face: 32, nose:10
//    int Vidx[] = {571,780,779,573,358,121,614,613,766,593,767,104,687,688,689,44,1,2426,2425,2424,1841,2504,2330,2503,2350,2351,1858,2095,2310,2516,2517,2308,107,751,268,211,21,23,1948,2005,2488,1844,238,235,330,228,219,242,241,240,1975,1972,2067,1965,1956,1979,1978,1977,355,191,694,684,269,197,339,29,2076,1934,2006,2421,2431,1928,2092,2533,1930,2532,50,795,193,796};
    int Vidx[] = {496,686,685,498,287,122,539,538,672,518,673,105,610,611,612,44,1,1799,2244,3284,3304,3308,3322,3323,3324,3349,3348,3402,3399,3371,3368,1991,234,216,138,212,21,23,1930,1831,1965,1954,283,1790,1788,1794,1791,598,255,221,3478,3486,3458,3476,3490,3495,1985,1946,284,192,617,607,232,198,269,29,2006,1959,1958,1910,1908,3312,3314,1903,1901,1904,50,701,194,702};
    for( size_t i = 0; i<sizeof(Vidx)/sizeof(*Vidx); i++ )
    {
        for ( BaseMesh::VertexIter v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it )
        {
            if( v_it->idx() == Vidx[i] )
            {
                control_pts.push_back(mesh.point(*v_it));
                control_pts_VH.push_back(*v_it);
                break;
            }
        }
    }
    // initialize parameter
    bc_frac = 1.0;
}

void OpenMeshObject::InitFHidx()
{
    // Clear
    allfaces.clear();
    interV.clear();
    // Face index
    std::vector<int> Fidx_vec;
    if(deform_times==1)
    {
//        int Fidx1[] = {7242,7210,7211,3221,3222,3458,3459,7212,7213,7254,3210,3209,3493,3492,3373,3374,7334,7333,7323,7309,7310,4141,4142,4143,4145,4144,4147,7330,7329,7332,7331,7285,7284,7283,7273,7278,7279,7106,7107,7150,7151,7096,7094,7093,7101,7102,7085,7084,7091,7092,7068,7061,7060,7076,7067,7075,7070,7069,7120,7121,7123,7122,7128,7127,7324,7325,7311,7326,7328,7327,7271,7272,7281,7282,7114,7112,7113,7149,7148,7147,7146,7145,7144,7143,7142,7141,7140,7139,7138,7137,7136,7135,7134,7133,7132,7130,7063,7062,7074,7073,7059,7058,7066,7065,7090,7089,7083,7082,7100,7099,7087,7086,7304,7305,7129,7301,7298,7360,7361,7358,7290,7359,7363,7362,7357,7343,942,941,7293,7356,7292,7297,7296,7299,7300,7024,7131,7126,7023,6950,6951,7125,6908,6907,6893,6924,6925,6891,6892,6850,6849,6852,6851,6894,6923,6922,6821,6824,6823,1057,720,719,1040,1056,1046,1047,916,915,917,4111,4231,3914,4109,1041,4232,3915,7168,7194,7193,7196,7189,7162,7163,7155,7154,7159,7158,7152,7153,293,294,174,173,7203,7202,7187,7188,7181,7182,698,697,6969,6970,7006,7005,7037,7038,7016,7015,6936,6937,6915,6878,6866,6865,6825,6826,6877,6914,6770,6771,92,91,120,119,1161,1160,1159,995,993,992,991,1089,1088,1087,1086,1055,774,678,677,18,17,206,175,176,708,6767,6766,707,205,6864,6938,6911,6880,6863,6804,6805,6879,6912,6939,7011,7040,7004,6952,282,281,7156,6953,7003,7039,7012,7157,7192,7191,7200,7201,7190,7198,7199,7184,7185,701,702,6973,6974,7186,7002,7001,7041,7042,7018,7017,6940,6941,6910,6909,6881,6882,6862,6861,6802,6803,6798,6799,706,705,16,15,768,767,765,766,6797,6796,6801,6800,6859,6860,6884,6883,6916,6917,7165,7164,7160,7183,280,279,365,364,256,255,6955,6954,7000,6999,7043,7044,7022,7021,6942,6943,275,7161,276,254,253,278,252,251,277,249,250,6956,6957,6981,6982,6979,6980,6971,6972,6997,7049,7047,6993,6998,7046,7045,6995,6994,6996,7026,7025,6944,6921,6945,7029,7048,7050,7028,6948,6949,6927,6926,6889,6890,6854,7027,7030,6946,6947,6929,6887,6856,6857,6886,6888,6928,6885,6920,6858,6812,6813,6815,6814,770,769,771,773,772,1053,1052,1050,1051,1048,1049,6819,6820,6818,6817,6855,6853,6816,6822,6807,6806,6811,760,759,764,763,900,899,1054,756,735,734,733,793,792,791,3986,3985,3984,3930,3929,3983,3974,3931,3932,737,782,789,897,898,6810,6769,762,776,775,761,6768,784,0,785,787,788,790,781,736,4,5,779,786,783,778,777,780,1,3,2,918,4110,3198,3199,3435,237,3201,238,3970,3434,3200,3975,3982,4091,3972,3971,3197,4237,4108,3973,3196,3976,3978,3980,3981,3979,3977,4238,4247,4248,6686,6687,6715,6710,6733,7110,7111,7109,7108,7280,7115,7116,6732,6741,7117,6740,6714,6685,6684,6647,3955,3968,3969,3949,4246,4245,3967,3966,3870,4279,3961,3963,4239,4240,4090,3928,4243,4277,4278,4280,3871,3960,3964,3965,4241,4242,3956,4093,4092,4244,3953,3954,3957,3952,6678,6744,6706,6765,6711,6648,6679,6707,6764,6735,6734,6626,6627,6608,6607,6589,6590,6558,6532,6533,6502,6503,4135,4134,6557,6895,6896,6847,6848,6808,6809,757,758,1042,1043,1044,4235,4236,4233,1045,4234,3950,3951,6677,6676,6739,6738,6743,7118,7119,6742,6637,7095,6638,6644,6643,6641,6642,6639,6640,4269,4270,4267,4268,4265,4266,4263,4264,1072,1073,1074,1075,1076,1077,1078,6843,1079,6842,6898,6897,6903,6904,944,943,945,946,948,947,13,14,327,368,367,369,371,370,328,951,953,949,952,954,955,956,957,958,239,240,996,997,247,248,366,168,167,1027,1026,1025,1024,3368,3367,4216,4215,4217,4218,3445,3444,4187,4188,3436,3437,4149,4146,4148,7209,3475,3474,3450,3451,3566,3565,7208,4136,4137,6511,6510,6531,6530,6554,6588,6609,6625,6736,6763,6762,6712,6713,6682,6683,6737,6624,6610,6587,6553,3568,3567,3569,3570,3526,3527,3211,3212,4139,6512,4138,6513,6529,6528,6555,6556,6586,6585,6605,6606,6623,6622,6730,6731,6761,6760,6708,6709,6680,6681,3962,3959,3958,6673,6672,6701,6700,6758,6759,6727,6726,6620,6621,6604,6603,6583,6584,6560,6559,6526,6527,6489,6495,6494,3448,3477,3476,3449,3447,3446,3563,3479,3478,7237,7236,7255,7243,7248,7247,7246,7216,7241,7240,7258,7259,7235,7234,3892,3893,6500,6501,6521,6520,6565,6566,6578,6577,6597,6598,6615,6614,6724,6725,6753,6716,6717,6649,6752,6522,6523,6488,6487,3480,3481,7207,7206,7257,7256,7244,7245,7239,7238,3897,3896,6490,3453,3564,3452,6504,6505,6524,6561,6562,6582,6581,6599,6600,6619,6618,6718,6719,6757,6756,6525,6580,6579,6593,6564,6594,6617,6616,6720,6721,6755,6754,6704,6563,6705,6646,6645,6702,6703,6674,6675,3900,3901,3213,3214,3215,4182,3216,4184,4183,4185,4351,4350,3320,3319,3292,3291,6650,3902,3903,3375,3376,3405,3406,4353,7291};
        int Fidx1[] = {0,1,2,3,4,5,10,11,12,13,86,87,114,115,139,140,141,142,160,161,176,177,180,181,182,183,192,193,194,195,196,197,206,207,237,238,540,541,549,550,553,554,557,558,559,560,571,572,584,585,586,587,588,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,725,726,727,728,740,741,742,743,786,787,788,789,790,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,834,835,836,837,838,839,840,841,846,847,848,849,918,919,920,2958,2959,2960,2961,2962,2963,2988,2989,2990,2991,2992,2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3013,3014,3015,3016,3017,3018,3034,3035,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,3051,3052,3053,3054,3055,3056,3057,3058,3069,3070,3071,3072,3073,3074,3075,3076,3077,3078,3079,3080,3081,3082,3083,3084,3085,3086,3087,3088,3089,3090,3095,3096,3099,3100,3101,3102,3103,3104,3106,3107,3108,3109,3112,3113,3114,3115,3116,3117,3118,3119,3120,3121,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,3141,3142,3143,3144,3145,3146,3147,3148,3149,3161,3162,3163,3164,3165,3166,3171,3182,3183,3184,3185,3186,3187,3188,3189,3190,3191,3192,3193,3194,3195,3200,3201,3204,3205,3206,3207,3210,3211,3212,3213,3214,3215,3216,3217,3218,3219,3226,3227,3228,3229,3230,3231,3232,3233,3234,3235,3236,3237,3238,3239,3247,3248,3249,3250,3251,3252,3254,3255,3256,3257,3258,3259,3262,3263,3264,3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,3296,3297,3298,3299,3300,3301,3304,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,3328,3329,3330,3332,3334,3335,3336,3337,3338,3339,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,3360,3361,3366,3367,3368,3369,3370,3379,3380,3381,3382,3383,3384,3385,3386,3391,3392,3393,3394,3409,3410,3413,3414,3421,3422,3423,3424,3425,3426,3427,3428,3429,3430,3431,3432,3473,3474,3475,3476,3477,3478,3483,3484,3485,3486,3559,3560,3587,3588,3612,3613,3614,3615,3633,3634,3649,3650,3653,3654,3655,3656,3665,3666,3667,3668,3669,3670,3679,3680,3710,3711,4013,4014,4022,4023,4026,4027,4030,4031,4032,4033,4044,4045,4057,4058,4059,4060,4061,4068,4069,4070,4071,4072,4073,4074,4075,4076,4077,4078,4079,4080,4081,4082,4083,4084,4085,4086,4087,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,4099,4100,4101,4102,4103,4104,4105,4198,4199,4200,4201,4213,4214,4215,4216,4259,4260,4261,4262,4263,4277,4278,4279,4280,4281,4282,4283,4284,4285,4286,4287,4288,4289,4290,4291,4292,4293,4294,4307,4308,4309,4310,4311,4312,4313,4314,4319,4320,4321,4322,4391,4392,4393,6431,6432,6433,6434,6435,6436,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,6473,6474,6475,6476,6477,6478,6479,6480,6481,6482,6483,6484,6485,6486,6487,6488,6489,6490,6491,6507,6508,6512,6513,6514,6515,6516,6517,6518,6519,6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6542,6543,6544,6545,6546,6547,6548,6549,6550,6551,6552,6553,6554,6555,6556,6557,6558,6559,6560,6561,6562,6563,6568,6569,6572,6573,6574,6575,6576,6577,6579,6580,6581,6582,6585,6586,6587,6588,6589,6590,6591,6592,6593,6594,6601,6602,6603,6604,6605,6606,6607,6608,6609,6610,6611,6612,6613,6614,6615,6616,6617,6618,6619,6620,6621,6622,6634,6635,6636,6637,6638,6639,6644,6655,6656,6657,6658,6659,6660,6661,6662,6663,6664,6665,6666,6667,6668,6673,6674,6677,6678,6679,6680,6683,6684,6685,6686,6687,6688,6689,6690,6691,6692,6699,6700,6701,6702,6703,6704,6705,6706,6707,6708,6709,6710,6711,6712,6720,6721,6722,6723,6724,6725,6727,6728,6729,6730,6731,6732,6735,6736,6737,6738,6739,6740,6741,6742,6743,6744,6745,6746,6747,6748,6749,6750,6751,6752,6753,6754,6755,6756,6757,6758,6759,6760,6761,6762,6763,6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6777,6790,6791,6792,6793,6794,6795,6796,6797,6798,6799,6800,6801,6802,6803,6805,6807,6808,6809,6810,6811,6812,6819,6820,6821,6822,6823,6824,6825,6826,6827,6828,6829,6830,6831,6832,6833,6838,6847,6848,6849,6850,6851,6852,6853,6858,6859,6860,6861,6877,6878,6881,6882,6889,6890,6891,6892,6893,6894,6895,6896,6897,6898,6899,6900,6940,6946,6947,6948,6949,6962,6964,6965,6966,6967,6968,6969,6976,6977,6978,6979};
        for( size_t i = 0; i<sizeof(Fidx1)/sizeof(*Fidx1); i++ )
        {
            Fidx_vec.push_back(Fidx1[i]);
        }
    }
    else if(deform_times==2)
    {
//        int Fidx2[] = {109,106,107,1068,115,111,913,911,674,673,672,671,922,924,2813,3432,4261,1071,1069,118,117,914,928,927,344,343,2815,235,236,1070,909,7120,7121,7123,7122,7128,7127,6923,6922,6895,6896,6847,6848,6843,1079,95,103,1067,1066,912,910,101,6904,6836,6842,1078,1077,96,108,102,6908,6894,104,675,925,6840,6834,6835,6844,6838,6839,114,112,6903,6907,6893,6850,1064,1062,2822,926,6898,1065,6897,105,2816,676,110,1061,1060,6841,116,113,3433,3318,6011,4120,4106,4107,4262,3309,3299,4263,4265,3298,4267,3296,3305,3304,4257,4258,3315,3317,100,1073,1072,4264,4266,6738,6739,6743,6642,6641,6631,4251,3312,4259,3308,4268,3306,3307,3300,3297,99,1044,1045,4235,4236,4233,4234,3951,6677,6676,6639,6640,4269,3295,3303,3950,4270,1074,1075,1042,98,1076,758,1043,4260,6890,6854,6853,6852,6851,6849,6892,6891,6924,6925,6926,6889,6927,6949,6948,6950,6951,7125,7126,7132,7133,7069,7070,7075,204,203,346,345,919,3404,3403,4103,7094,7096,7093,7101,3544,7091,7067,4117,3543,4104,3868,4102,920,4114,3864,3866,3301,3302,7095,7061,7068,7084,7085,7102,7060,7076,7135,7134,7137,7139,7141,7142,7089,7090,7077,7078,3327,3425,225,128,7054,7072,7071,7074,7073,7138,7147,7087,7081,7080,3226,3387,4181,3322,3325,3326,125,126,978,984,908,7058,7065,7144,7146,7099,7097,4163,3551,3384,3383,184,183,353,351,122,187,7064,127,7088,4101,4165,3321,3541,3540,3552,963,124,1081,7290,7298,7301,7305,7129,7057,7056,7055,7079,7098,3549,3550,350,990,7066,7083,7100,3330,121,973,974,26,7053,7124,7130,7063,3225,3380,4168,7136,7082,4169,3423,224,989,180,7304,7131,7024,7023,7028,7027,7360,7361,7356,7357,7362,7363,7359,7358,7291,1083,123,341,352,964,23,186,975,976,1080,185,25,342,7062,921,4115,3867,3545,4112,4113,7092,7145,7143,7051,7059,872,873,977,223,981,874,3424,4172,4105,3865,4121,3542,4116,923,97,7140,6808,6809,6823,6806,6807,6816,6822,6821,1046,1047,916,915,917,918,4110,4111,4109,4108,4237,4238,6685,6684,6687,6686,4248,4247,3914,3915,4232,4231,1041,1040,719,720,1057,1056,6824,757,3869,4119,4118,4252,4254,6635,3316,6629,6628,6630,6637,6638,6014,6634,3311,6633,6643,6644,7106,7279,7107,7086,7148,7149,7150,7151,7113,7114,7282,7355,7351,7352,7286,7287,347,959,960,348,349,754,755,966,970,965,962,961,3401,202,201,32,31,3232,3231,4157,4161,3546,4160,3402,969,4154,4150,4151,4155,3324,3323,4152,4153,4166,4167,3385,7103,7105,4164,6632,6636,4255,3310,6015,4256,6744,6707,6706,6764,6765,6711,6710,6715,6714,6734,6733,6732,6740,6742,6741,6735,6626,6627,6608,6607,6589,6590,7280,7281,7112,7119,7117,7116,7115,7118,7111,7109,7108,7110,7278,7273,7285,7331,7332,7324,7323,7333,7334,7330,7329,7283,7284,4271,3314,875,980,4272,3224,3386,4156,7288,7353,7348,7347,1005,7320,7314,7315,4195,4206,4205,3883,3882,4199,3576,731,376,1009,1008,688,1015,1014,7289,189,24,188,230,1082,7302,7303,228,7294,7052,229,7295,4200,3575,377,687,7349,7339,7340,7337,7338,752,7342,29,750,753,7341,3229,3230,7270,967,4159,3547,4273,4274,6491,3389,7261,3548,7262,4158,30,7318,7322,7319,7266,7265,7321,7317,7316,3881,3925,1010,7350,7354,968,7267,3946,3948,7268,3947,751,3945,3227,28,27,1013,1012,1011,730,3926,4202,3880,4201,4204,4203,3228,7269,7264,6492,6493,7275,7274,7276,7277,7263,3388,3223,7104,1016,1017,691,692,1007,1006,374,4207,4208,3887,3886,4197,4198,3574,375,3573,3313,6017,6012,6013,6010,6008,6009,2814,2817,2818,2820,4180,4067,4065,4066,4068,4173,4175,4176,3328,2821,2819,6016,985,971,988,983,4179,4171,3379,972,4162,179,979,182,986,987,4177,4178,4170,3381,3382,4174,129,130,982,1063,4253,3329,181,6837};
        int Fidx2[] = {18,19,20,21,22,23,24,25,26,27,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,116,117,118,119,120,121,122,123,124,125,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,164,165,166,169,170,171,174,175,214,215,216,217,218,219,220,221,222,223,224,225,226,241,242,243,244,534,535,536,537,538,539,571,572,582,583,589,590,591,592,593,594,596,597,706,707,708,709,733,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,754,755,756,757,758,759,760,761,762,763,764,765,766,767,768,769,770,771,772,773,774,775,776,777,778,779,780,781,782,783,784,785,791,792,793,794,795,796,797,798,804,805,806,807,808,809,810,811,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,2561,2562,2563,2564,2565,2566,2567,2568,2569,2570,2998,2999,3000,3001,3008,3013,3014,3015,3016,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3039,3040,3041,3042,3043,3044,3045,3046,3081,3082,3083,3084,3085,3086,3087,3088,3089,3090,3095,3096,3099,3100,3114,3115,3116,3117,3118,3119,3140,3141,3142,3143,3212,3213,3216,3217,3240,3241,3242,3243,3244,3245,3246,3247,3248,3249,3250,3251,3252,3253,3254,3255,3256,3257,3258,3259,3260,3261,3262,3263,3264,3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286,3287,3342,3343,3344,3345,3346,3347,3350,3351,3354,3357,3358,3359,3360,3361,3362,3363,3364,3365,3366,3367,3368,3369,3370,3400,3401,3402,3403,3404,3405,3406,3449,3450,3453,3454,3491,3492,3493,3494,3495,3496,3497,3498,3499,3500,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,3574,3575,3576,3577,3578,3579,3580,3581,3582,3583,3584,3585,3586,3589,3590,3591,3592,3593,3594,3595,3596,3597,3598,3618,3619,3620,3621,3622,3623,3624,3625,3626,3627,3628,3629,3630,3631,3632,3637,3638,3639,3642,3643,3644,3647,3648,3687,3688,3689,3690,3691,3692,3693,3694,3695,3696,3697,3698,3699,3714,3715,3716,3717,4007,4008,4009,4010,4011,4012,4044,4045,4055,4056,4062,4063,4064,4065,4066,4067,4069,4070,4179,4180,4181,4182,4206,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,4220,4221,4222,4223,4224,4225,4226,4227,4228,4229,4230,4231,4232,4233,4234,4235,4236,4237,4238,4239,4240,4241,4242,4243,4244,4245,4246,4247,4248,4249,4250,4251,4252,4253,4254,4255,4256,4257,4258,4264,4265,4266,4267,4268,4269,4270,4271,4277,4278,4279,4280,4281,4282,4283,4284,4293,4294,4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,4311,4312,4313,4314,4315,4316,4317,4318,6034,6035,6036,6037,6038,6039,6040,6041,6042,6043,6471,6472,6473,6474,6481,6486,6487,6488,6489,6499,6500,6501,6502,6503,6504,6505,6506,6507,6508,6509,6512,6513,6514,6515,6516,6517,6518,6519,6554,6555,6556,6557,6558,6559,6560,6561,6562,6563,6568,6569,6572,6573,6587,6588,6589,6590,6591,6592,6613,6614,6615,6616,6685,6686,6689,6690,6713,6714,6715,6716,6717,6718,6719,6720,6721,6722,6723,6724,6725,6726,6727,6728,6729,6730,6731,6732,6733,6734,6735,6736,6737,6738,6739,6740,6741,6742,6743,6744,6745,6746,6747,6748,6749,6750,6751,6752,6753,6754,6755,6756,6757,6758,6759,6760,6815,6816,6817,6818,6819,6820,6822,6823,6826,6829,6830,6831,6832,6833,6834,6835,6836,6837,6838,6867,6868,6869,6870,6871,6872,6917,6918,6921,6939,6940,6941,6942,6944,6945,6948,6949,6961,6963,6964,6965,6966,6967,6968,6970,6971,6972,6974,6975,6978,6979,6988,6991};
        for( size_t i = 0; i<sizeof(Fidx2)/sizeof(*Fidx2); i++ )
        {
            Fidx_vec.push_back(Fidx2[i]);
        }
    }
    else if(deform_times==3)
    {
        int Fidx3[] = {679,11,329,330,332,138,3171,3170,2804,2805,3153,3168,316,211,3162,3165,3151,3176,3167,3166,3169,139,3152,3175,192,212,334,208,193,194,3173,3172,2807,2806,12,680,191,190,6,137,903,196,209,3147,2808,195,3159,3158,3156,3145,144,136,3155,2810,312,207,141,140,3146,3157,197,273,234,233,2809,3144,135,871,151,245,274,243,172,870,869,150,248,247,369,996,240,280,279,365,364,256,255,6955,6954,6957,6981,6982,6979,6980,6971,6972,7292,7293,7356,7357,7362,7363,7355,7354,7338,7337,7339,7340,688,687,691,692,686,685,893,894,895,892,1121,1122,269,270,1030,1031,1028,275,276,294,293,271,272,290,289,231,232,1120,1119,896,890,891,889,999,1000,1001,1003,1014,1015,7350,7349,1016,1017,888,887,1004,7347,7348,7353,1005,1002,325,741,7336,742,171,326,1037,7346,1036,929,1039,1038,7345,7335,324,745,998,867,868,266,264,149,148,131,218,169,746,747,265,302,2802,3161,3148,3149,262,261,301,299,3160,669,684,681,744,738,739,263,683,3163,215,216,303,300,322,133,147,298,304,306,1018,1019,1020,296,132,3143,2803,320,3142,321,146,134,1027,366,368,277,252,371,370,997,251,249,250,13,6956,947,948,955,954,953,946,951,944,952,949,942,7343,7344,941,943,945,950,931,934,933,932,930,935,740,902,901,743,670,682,267,268,170,217,3164,3150,210,940,198,310,938,956,937,936,958,939,244,239,957,14,327,328,367,253,278,254,173,174,1029,749,748,291,292,200,199,167,168,1024,1023,1021,1022,219,1025,222,297,732,1026,221,2823,318,317,1085,319,1084,315,331,2811,3174,3154,145,308,142,143,307,2812,1058,1059,152,153,323,305,295,220,668,667,333,314,313,311,309,246,6001,6000,6356,6354,6002,6347,6349,4063,3473,3407,3396,6368,6006,6342,3408,3528,3531,6366,6341,3393,4130,4128,3394,3345,4062,3397,3430,3431,5999,6355,5998,6337,6353,6495,6489,6490,3453,3452,3564,3563,3479,3478,3475,3474,3492,3493,3471,3470,3488,3489,3429,3428,4310,4088,4089,4086,4311,4087,3879,3878,3886,3887,3883,3882,3881,7316,7317,7314,7320,7312,7308,4230,4141,7311,4134,4135,4136,4138,4139,3212,6494,6513,6512,4137,6503,7325,7323,7333,7334,7322,7321,7266,7265,3880,7324,7326,6502,6511,6510,4149,4148,4146,4147,3211,3527,3447,3446,3449,3448,3477,3476,3451,3450,3374,3373,4220,4221,4219,4222,3468,3469,4312,4313,4084,4085,4082,4083,4081,4080,4207,4205,4206,4208,4193,4194,4191,4195,7315,7306,7313,4228,4229,4124,4127,4142,4143,4145,4144,7310,7309,4125,4126,4129,4140,3872,3207,4131,4133,4132,3437,3436,3570,3569,3567,4188,3526,3568,3565,3566,4216,4214,4213,3400,3491,3943,3944,3942,4060,4061,4190,4192,4196,4189,3418,3503,3333,3494,4212,4211,3490,3399,3368,3367,4217,4218,3351,3350,4064,4187,3445,3441,3440,3444,3472,3336,3334,3421,4215,3420,3497,3332,3502,4210,3505,4209,3465,3463,3462,3348,3467,3874,3938,3371,4094,4095,4227,3936,3523,3524,3937,3939,3466,3935,7307,3525,4123,4122,3390,3391,3202,3337,3860,3863,3877,3416,3876,3862,4096,6371,6361,3412,6018,3861,3518,3392,3516,3940,3875,3349,3331,3934,3415,6345,6343,6344,6357,3460,6358,6359,6360,6346,6370,6362,6363,6348,6364,6365,3339,3338,3410,3411,3873,3208,3529,3530,6367,3409,3395,3340,3341,6004,6003,3398,6005,6369,3532,3533,3515,3514,4276,4275,3517,3461,3498,3499,3500,3501,3520,3519,3522,6338,3521,5997,6351,6352,6339,3346,3347,3496,3335,3422,3927,3512,3513,3511,3510,3419,3495,3504,3369,3941,3370,3417,3933,3464,3344,6007,6350,3343,3506,3353,6340,3352,4249,4250,3507,3442,3372,3342,3443,3509,3508};
        for( size_t i = 0; i<sizeof(Fidx3)/sizeof(*Fidx3); i++ )
        {
            Fidx_vec.push_back(Fidx3[i]);
        }
    }
    else if(deform_times==4)
    {
//        int Fidx4[] = {226,227,1114,1113,861,862,703,704,718,717,876,877,4069,4070,3913,3912,3898,3899,4054,4055,4305,4304,3426,3427,3220,3534,3535,3222,3219,7211,7210,3221,22,21,336,335,7154,7155,7163,7165,7162,7164,7160,7161,275,276,254,253,278,277,371,370,328,240,239,957,958,956,955,954,953,946,945,943,944,951,952,933,934,680,679,210,138,3171,3170,2804,2805,3161,3163,264,266,265,217,747,746,1121,892,896,866,865,863,864,1116,1118,1117,1120,1122,269,749,748,270,232,1115,7,8,694,286,285,288,287,290,260,259,7152,7153,293,294,7158,7159,9,10,1029,1028,168,1027,150,996,997,870,136,1059,147,297,296,291,231,693,132,321,146,3144,3145,320,289,200,367,366,247,243,145,144,298,1021,292,1031,1030,167,1025,151,135,1023,219,134,308,309,307,1022,871,869,222,1024,368,369,252,250,732,248,1026,199,272,174,173,273,198,3155,3154,271,7189,7196,7193,7194,7168,7203,7202,7187,7188,7181,7182,698,697,6969,6970,7006,7005,7037,7038,7016,7015,6936,6937,6915,6914,6877,6878,6866,6865,6825,6826,6770,6804,6863,6864,6880,6879,6911,6912,6939,6938,7012,7040,7039,7004,6953,6952,282,281,7156,7157,7192,7191,7200,7201,7011,7003,7185,7184,7198,7190,7199,7183,280,279,365,251,249,6957,256,255,702,6973,6955,6954,7000,364,7186,701,6974,7001,7041,7042,7002,7018,6940,6910,6909,6916,6917,6943,6942,7021,7017,6941,7022,7044,7043,6999,6881,6862,6861,6860,6884,6883,6859,6882,6920,6921,6945,7025,7026,7045,6995,6996,6981,6956,13,327,7046,6944,7047,6993,6979,6980,948,947,6982,6994,14,939,234,274,244,940,172,193,233,3159,936,937,1084,3168,3162,2802,3175,3165,215,262,938,194,208,3153,3160,2807,2806,329,903,683,935,211,1085,318,319,2823,3167,3166,12,330,11,332,316,317,670,684,331,209,3152,334,681,743,745,669,261,1020,3150,3149,3148,3147,3146,3164,195,312,6771,92,91,120,119,1160,1161,176,1159,206,205,17,18,677,678,768,767,765,6797,6796,6801,6800,766,16,15,705,706,6799,6798,6803,6802,6805,6766,6767,708,707,175,774,773,771,772,769,770,6814,6815,6813,6812,6857,6858,6886,6885,6946,7029,7048,7030,6947,6929,6928,6887,6888,6856,6855,6817,6818,6820,6819,1049,1048,1051,1050,1052,1053,993,995,992,991,1089,1088,1087,1086,1055,1054,1119,1018,305,302,3173,3172,3143,3142,301,3158,304,1019,3157,133,3156,2810,311,141,3174,2811,196,2809,2808,1058,207,140,2812,310,143,197,221,2803,299,303,139,191,190,212,192,3169,148,149,131,267,268,739,868,891,867,682,744,998,999,889,890,893,894,895,738,362,363,19,20,689,690,258,257,3455,3454,3884,3885,3217,3218,4057,4056,4306,4308,3888,3203,3204,3484,4307,4309,4059,4058,3562,3561,4224,4223,4226,4225,1035,1034,1033,1032,3151,3176,169,170,932,930,929,1039,1038,6,171,742,685,888,887,1001,1002,1003,1004,1005,7347,7348,7353,7362,7363,7359,7358,7361,7360,7298,7290,7336,741,325,324,1000,1036,326,7346,7335,902,1016,901,740,1037,7344,7345,7357,7356,7343,942,949,950,931,941,7293,7292,7297,6972,6971,6998,7027,7028,7049,6997,7050,6948,6949,6927,6950,7024,7300,7299,7296,7023,6951,6924,6907,6908,7125,7126,263,220,7301,7305,7304,7129,7130,7132,7133,7120,7128,7127,6923,6922,6895,7131,6893,6894,6850,6848,6847,6843,6842,6838,1062,7123,7121,6891,6853,6849,6896,6836,6904,7122,6897,6898,6839,6834,6840,6841,101,6903,1064,1066,116,676,910,909,7069,7070,6925,6926,6889,6890,6854,6806,6807,6810,6811,6892,6852,6851,6816,6822,6768,6769,735,756,734,733,793,792,791,3986,3985,3984,3930,3929,3928,3949,4246,4245,4243,3967,3966,4277,4280,4279,4182,4184,4278,3870,4244,4092,4093,4090,4091,3982,3983,3975,3974,3931,3932,736,737,782,781,789,790,897,898,899,900,759,760,764,763,776,775,787,788,780,4,3201,5,779,3200,3973,3978,3955,3968,3969,3981,3980,3957,4242,3965,3961,3960,4183,4185,4351,4350,4353,3320,3319,3405,3406,3216,3215,3871,3959,3901,3903,3902,3291,3376,3375,3292,6649,6646,6650,6705,6716,6717,6752,6753,6725,6724,6614,6615,6598,6597,6577,6578,6566,6565,6520,6521,6501,6500,6488,6522,6563,6564,6579,6593,6594,6617,6616,6720,6721,6755,6754,6704,6645,3214,3213,3964,4241,3956,3972,3971,3970,3197,3976,6647,6648,3954,3979,6684,3977,6678,6679,6683,6682,6681,6680,6673,6672,6675,6674,3900,3958,3962,3963,4239,4240,3952,3953,6703,6702,6756,6757,6718,6618,6600,6599,6581,6561,6524,6505,3896,3897,6525,6719,6582,6619,6562,6504,7239,7207,3480,6580,6523,6487,3481,3893,3892,7234,7235,7259,7258,7240,7241,7248,7247,7246,7216,7245,7243,7242,7244,7256,7257,7206,7255,7254,7236,7238,7237,7212,3458,3459,7213,7209,7208,3210,3457,3456,3485,3206,3209,3493,3475,3478,3479,3563,3564,3452,3453,6490,6489,6526,6559,6560,6584,6583,6603,6604,6620,6726,6727,6759,6758,6700,6701,6621,6527,762,761,785,786,777,3435,237,238,0,778,3434,3199,3198,3196,3,1,1047,1046,783,784,2,918,917,915,916,6821,6824,6823,1057,720,1040,1041,4231,719,1056,4232,3915,3914,4111,4110,4109,4108,4237,4238,6685,6744,6706,6707,6712,6713,6708,6761,6731,6709,6760,6730,6622,6623,6606,6605,6585,6556,6555,6528,6529,6513,6586,6495,6494,3446,3447,3449,3448,3492,3474,3476,3477,3451,3450,3568,3567,3373,4219,3470,3471,3205,3486,3487,3889,4086,4085,4082,4060,4061,3467,3348,3876,3877,3872,4126,4127,4142,4135,6503,6502,6532,6558,6590,6589,6607,6608,6627,6626,6734,6735,6765,6764,6763,6762,6711,6715,6687,6686,4248,4247,6710,6733,6736,6624,6625,6610,6587,6588,6530,6510,4137,6511,6557,6533,6531,6553,6554,6609,6737,6512,4139,3212,3211,3526,3570,3569,3527,4188,3566,3368,3374,3565,3367,4220,4221,4222,3468,3469,3489,3429,3428,4310,3488,4088,4311,4312,4089,4084,4313,3942,4209,4212,4211,3491,3399,3490,3944,3400,3943,3494,3495,3335,4063,4062,3927,3351,4064,4187,3444,4217,4215,3445,4218,3350,4216,3422,3336,3334,3344,3421,4214,3497,3419,3420,4213,3496,3346,3345,3430,4132,3437,3436,3441,3472,3440,3473,6350,3431,4148,4149,4138,4136,4145,4146,4144,7326,7325,7310,4140,4230,4229,3525,7313,7320,7333,7334,7330,7329,7283,7285,7273,7284,7278,7279,7106,7150,7151,7107,7332,7323,7308,4123,7324,7331,7309,4228,7281,7108,7271,7327,7272,7328,7111,7110,7116,6738,6676,686,372,373,711,712,3906,3907,3571,3572,3878,3879,4081,4083,4087,4080,4192,4189,4191,3937,3371,6371,6370,6346,3875,3874,3940,3939,3934,4190,4194,4193,4196,4195,7315,3935,3936,3523,3524,7314,4208,3938,3860,3202,4094,4095,4227,7306,7312,7282,7114,7115,7280,7109,7117,7119,7112,7118,7307,3862,4096,3863,4122,3337,6361,3391,3518,6018,6362,6363,3392,3412,3390,4124,4125,3338,6364,7311,4134,4143,4141,4147,4131,4130,3393,3207,4128,4129,3394,3407,3408,3409,3528,3529,3208,4133,3398,3341,3340,3342,3397,3508,3510,3343,3442,3372,3443,3509,6006,6342,6341,6005,3507,4250,6352,6351,6001,6000,6366,6368,6004,6369,3511,6349,5999,6002,6358,6359,6348,6347,6357,3416,6345,3349,6360,3415,3331,3466,6343,6344,6355,5998,5997,6356,6353,6365,3339,3410,3532,6367,3411,3873,3530,3531,3395,3396,6003,3513,3512,3533,3515,3514,4275,3517,4276,3516,3933,3370,3417,3465,3464,3463,4210,3941,3369,3462,3503,3505,3418,3499,3502,3504,3500,3501,6338,6337,3519,3332,3333,3520,6354,6339,6340,3347,6007,4249,3353,3506,3352,3522,3521,3498,3461,3460,3861,152,322,153,323,295,300,216,218,137,667,668,315,333,313,314,246,142,306,245,6808,6809,757,758,1042,1043,1044,1072,4264,4236,4235,4233,3950,3951,6677,1045,4234,6714,6741,6740,6743,6732,6739,6642,6643,6644,6637,6742,7113,7096,7095,6638,7094,3404,3867,3866,3317,3302,3869,3315,4260,3306,4267,6639,4256,4255,4257,3304,4269,6633,3295,3303,6640,6631,6636,4254,6641,6628,6629,6632,6635,4118,3312,3314,6634,4119,4270,3298,4265,4266,4268,4263,108,106,1077,1078,1079,103,95,926,6844,925,102,6835,912,110,113,675,1065,114,1067,105,104,96,1076,1075,1074,1073,109,1071,107,1068,1069,1070,118,117,115,236,3432,3433,3318,4258,235,3316,3305,3307,4259,4262,4261,3309,3308,7063,7062,7074,7073,7059,7058,7066,7065,7090,7089,7083,7082,7100,7099,7087,7086,7149,7148,7147,7146,7145,7144,7143,7142,7140,7139,7138,7137,7136,7135,7134,7076,7060,7068,7091,7085,7075,204,203,674,911,673,346,671,4113,7092,7084,7141,7067,7061,345,920,919,4112,3544,3403,4103,4102,7093,7101,7102,3545,3301,3296,3297,3300,3299,99,100,97,98,1061,1063,2822,1060,111,914,928,344,924,3543,4120,4106,4107,3311,4252,4251,4253,3313,3868,4104,4105,3864,4114,4115,672,922,3865,921,4121,3542,4116,923,343,4117,927,913,2818,2820,2817,2819,2821,112,2816,2815,2814,2813,6010,6009,6011,6008,6012,6013,3310,6014,6015,6016,6017,1017,691,692,1007,1006,374,375,3573,4198,4197,3886,3887,4207,3574,1015,688,1008,1009,376,1014,687,377,3575,4199,4200,3882,4206,4205,3883,3576,7350,7349,7339,7340,1010,731,730,3926,3925,4201,4202,3880,3881,7316,7317,1011,7291,7295,7289,7288,188,189,24,23,186,185,7053,7124,7052,230,7294,229,228,7302,7303,7051,7055,127,128,872,873,225,223,224,977,7077,7078,3327,4066,4065,3425,3328,3423,3424,4169,7277,7263,7264,3389,3388,3223,3224,3385,3386,7103,7104,7105,7275,6493,6492,6491,7276,7274,351,350,978,4168,3550,3549,6630,6837,4186,994};
        int Fidx4[] = {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,86,87,90,91,92,93,94,95,96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,120,122,123,139,140,141,142,151,152,154,155,158,159,160,161,164,165,166,167,168,169,170,171,172,173,174,175,176,177,180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,200,201,202,203,204,205,206,207,208,209,216,217,218,219,222,223,224,235,236,237,238,239,240,241,242,243,244,534,535,536,537,538,539,540,541,542,543,544,545,546,549,550,553,554,555,556,557,558,559,560,563,564,569,570,571,572,584,585,586,587,588,595,596,597,598,599,600,601,602,603,604,605,606,607,608,609,610,611,612,613,614,615,616,617,618,619,620,621,622,623,624,625,626,627,628,629,630,631,632,700,701,702,703,704,705,706,707,710,711,721,722,723,724,725,726,727,728,734,735,736,737,738,739,740,741,742,743,744,745,746,747,748,749,750,751,752,753,770,771,772,773,774,786,787,788,789,790,791,792,793,794,799,800,801,802,803,804,805,806,807,808,809,810,811,812,813,814,815,816,817,818,819,820,821,822,823,824,825,826,827,828,829,830,831,832,833,834,835,836,837,838,839,840,841,842,843,844,845,846,847,848,849,873,874,875,876,877,878,879,880,881,918,919,920,2561,2562,2563,2564,2565,2566,2567,2568,2569,2570,2958,2959,2960,2961,2962,2963,2988,2989,2990,2991,2992,2993,2994,2995,2996,2997,2998,2999,3000,3001,3002,3003,3004,3005,3006,3007,3008,3009,3010,3011,3012,3013,3014,3015,3016,3017,3018,3026,3027,3028,3029,3030,3031,3032,3033,3034,3035,3036,3039,3040,3041,3042,3043,3044,3045,3046,3047,3048,3049,3050,3051,3052,3053,3054,3055,3056,3057,3058,3069,3070,3071,3072,3073,3074,3075,3076,3077,3078,3079,3080,3081,3082,3083,3084,3085,3086,3087,3088,3089,3090,3095,3096,3099,3100,3101,3102,3103,3104,3106,3107,3108,3109,3112,3113,3114,3115,3116,3117,3118,3119,3120,3121,3128,3129,3130,3131,3132,3133,3134,3135,3136,3137,3138,3139,3140,3141,3142,3143,3144,3145,3146,3147,3148,3149,3161,3162,3163,3164,3165,3166,3171,3182,3183,3184,3185,3186,3187,3188,3189,3190,3191,3192,3193,3194,3195,3200,3201,3204,3205,3206,3207,3210,3211,3212,3213,3214,3215,3216,3217,3218,3219,3226,3227,3228,3229,3230,3231,3232,3233,3234,3235,3236,3237,3238,3239,3240,3241,3242,3244,3247,3248,3249,3250,3251,3252,3254,3255,3256,3257,3258,3259,3262,3263,3264,3265,3266,3267,3268,3269,3270,3271,3272,3273,3274,3275,3276,3277,3278,3279,3280,3281,3282,3283,3284,3285,3286,3287,3288,3289,3290,3291,3292,3293,3294,3295,3296,3297,3298,3299,3300,3301,3304,3317,3318,3319,3320,3321,3322,3323,3324,3325,3326,3327,3328,3329,3330,3332,3334,3335,3336,3337,3338,3339,3343,3344,3345,3346,3347,3348,3349,3350,3351,3352,3353,3354,3355,3356,3357,3358,3359,3360,3361,3366,3367,3368,3369,3370,3371,3372,3373,3374,3375,3376,3377,3378,3379,3380,3381,3382,3383,3384,3385,3386,3387,3388,3389,3390,3391,3392,3393,3394,3395,3396,3397,3398,3399,3400,3401,3402,3407,3408,3409,3410,3411,3412,3413,3414,3415,3416,3417,3418,3419,3420,3421,3422,3423,3424,3425,3426,3427,3428,3429,3430,3431,3432,3433,3434,3435,3436,3437,3438,3439,3440,3441,3442,3443,3444,3445,3446,3447,3448,3449,3450,3451,3452,3453,3454,3455,3456,3457,3458,3459,3460,3461,3462,3463,3464,3465,3466,3467,3468,3469,3470,3471,3472,3473,3474,3475,3476,3477,3478,3479,3480,3481,3482,3483,3484,3485,3486,3487,3488,3489,3490,3491,3492,3559,3560,3563,3564,3565,3566,3567,3568,3569,3570,3571,3572,3573,3574,3575,3576,3577,3578,3579,3580,3581,3582,3583,3584,3585,3586,3587,3588,3593,3595,3596,3612,3613,3614,3615,3624,3625,3627,3628,3631,3632,3633,3634,3637,3638,3639,3640,3641,3642,3643,3644,3645,3646,3647,3648,3649,3650,3653,3654,3655,3656,3657,3658,3659,3660,3661,3662,3663,3664,3665,3666,3667,3668,3669,3670,3673,3674,3675,3676,3677,3678,3679,3680,3681,3682,3689,3690,3691,3692,3695,3696,3697,3708,3709,3710,3711,3712,3713,3714,3715,3716,3717,4007,4008,4009,4010,4011,4012,4013,4014,4015,4016,4017,4018,4019,4022,4023,4026,4027,4028,4029,4030,4031,4032,4033,4036,4037,4042,4043,4044,4045,4057,4058,4059,4060,4061,4068,4069,4070,4071,4072,4073,4074,4075,4076,4077,4078,4079,4080,4081,4082,4083,4084,4085,4086,4087,4088,4089,4090,4091,4092,4093,4094,4095,4096,4097,4098,4099,4100,4101,4102,4103,4104,4105,4173,4174,4175,4176,4177,4178,4179,4180,4183,4184,4194,4195,4196,4197,4198,4199,4200,4201,4207,4208,4209,4210,4211,4212,4213,4214,4215,4216,4217,4218,4219,4220,4221,4222,4223,4224,4225,4226,4243,4244,4245,4246,4259,4260,4261,4262,4263,4264,4265,4266,4267,4272,4273,4274,4275,4276,4277,4278,4279,4280,4281,4282,4283,4284,4285,4286,4287,4288,4289,4290,4291,4292,4293,4294,4295,4296,4297,4298,4299,4300,4301,4302,4303,4304,4305,4306,4307,4308,4309,4310,4311,4312,4313,4314,4315,4316,4317,4318,4319,4320,4321,4322,4346,4347,4348,4349,4350,4351,4352,4353,4354,4391,4392,4393,6034,6035,6036,6037,6038,6039,6040,6041,6042,6043,6431,6432,6433,6434,6435,6436,6461,6462,6463,6464,6465,6466,6467,6468,6469,6470,6471,6472,6473,6474,6475,6476,6477,6478,6479,6480,6481,6482,6483,6484,6485,6486,6487,6488,6489,6490,6491,6499,6500,6501,6502,6503,6504,6505,6506,6507,6508,6509,6512,6513,6514,6515,6516,6517,6518,6519,6520,6521,6522,6523,6524,6525,6526,6527,6528,6529,6530,6531,6542,6543,6544,6545,6546,6547,6548,6549,6550,6551,6552,6553,6554,6555,6556,6557,6558,6559,6560,6561,6562,6563,6568,6569,6572,6573,6574,6575,6576,6577,6579,6580,6581,6582,6585,6586,6587,6588,6589,6590,6591,6592,6593,6594,6601,6602,6603,6604,6605,6606,6607,6608,6609,6610,6611,6612,6613,6614,6615,6616,6617,6618,6619,6620,6621,6622,6634,6635,6636,6637,6638,6639,6644,6655,6656,6657,6658,6659,6660,6661,6662,6663,6664,6665,6666,6667,6668,6673,6674,6677,6678,6679,6680,6683,6684,6685,6686,6687,6688,6689,6690,6691,6692,6699,6700,6701,6702,6703,6704,6705,6706,6707,6708,6709,6710,6711,6712,6713,6714,6715,6717,6720,6721,6722,6723,6724,6725,6727,6728,6729,6730,6731,6732,6735,6736,6737,6738,6739,6740,6741,6742,6743,6744,6745,6746,6747,6748,6749,6750,6751,6752,6753,6754,6755,6756,6757,6758,6759,6760,6761,6762,6763,6764,6765,6766,6767,6768,6769,6770,6771,6772,6773,6774,6777,6790,6791,6792,6793,6794,6795,6796,6797,6798,6799,6800,6801,6802,6803,6805,6807,6808,6809,6810,6811,6812,6816,6817,6818,6819,6820,6821,6822,6823,6824,6825,6826,6827,6828,6829,6830,6831,6832,6833,6838,6839,6840,6841,6842,6843,6844,6845,6846,6847,6848,6849,6850,6851,6852,6853,6854,6855,6856,6857,6858,6859,6860,6861,6862,6863,6864,6865,6866,6867,6868,6873,6874,6875,6876,6877,6878,6879,6880,6881,6882,6883,6884,6885,6886,6887,6888,6889,6890,6891,6892,6893,6894,6895,6896,6897,6898,6899,6900,6901,6902,6903,6904,6905,6906,6907,6908,6909,6910,6911,6912,6913,6914,6915,6916,6917,6918,6919,6920,6921,6922,6923,6924,6925,6926,6927,6928,6929,6930,6931,6932,6933,6934,6935,6936,6937,6938,6940,6942,6943,6946,6947,6948,6949,6950,6951,6952,6953,6954,6955,6956,6957,6958,6959,6960,6961,6962,6964,6965,6966,6967,6968,6969,6970,6972,6973,6976,6977,6978,6979,6980,6981,6982,6983,6984,6985,6986,6987,6988,6989,6990,6991};
        for( size_t i = 0; i<sizeof(Fidx4)/sizeof(*Fidx4); i++ )
        {
            Fidx_vec.push_back(Fidx4[i]);
        }
    }
    const int F_size = Fidx_vec.size();
    int Fidx[F_size];
    for( size_t i = 0; i<Fidx_vec.size(); i++ )
    {
        Fidx[i] = Fidx_vec[i];
    }
    // internal vertex
    const int n = mesh.n_vertices();
    std::vector<bool> isUse(n,false);
    // Set allfaces
    for(size_t i = 0; i<sizeof(Fidx)/sizeof(*Fidx); i++ )
    {
        for( BaseMesh::FaceIter f_it = mesh.faces_begin(); f_it != mesh.faces_end(); ++f_it )
        {
            if( f_it->idx() == Fidx[i] )
            {
                allfaces.push_back(f_it);
                int count = 0;
                for ( BaseMesh::FaceVertexIter fv_it = mesh.fv_iter(*f_it); fv_it.is_valid(); ++fv_it )
                {
                    count += 1;
                    if (count == 1)
                    {
                        isUse[fv_it->idx()] = true;
                    }
                    if (count == 2)
                    {
                        isUse[fv_it->idx()] = true;
                    }
                    if (count == 3)
                    {
                        isUse[fv_it->idx()] = true;
                    }
                }
            }
        }
    }
    // Boundary vertex index
    std::vector<int> BoundaryVertex_vec;
    if(deform_times==1)
    {
//        int BoundaryVertex1[] = {1866,1883,2375,1917,1922,3680,2022,2105,2229,2560,3582,2134,3589,2135,3603,2102,3611,2103,1924,1927,2468,1835,2467,1834,1832,2540,2509,2327,2374,28,637,590,772,803,95,97,98,730,731,190,187,366,3623,365,3639,398,3649,397,3666,823,492,368,285,3678,185,180,638,146,129,124,128,114,113,261,258,745,247,246,255,675,295,291,714,713,712,711,706,700,348,340,106,107,751,600,268,797,602,218,23,1955,2339,2534,2005,2337,2488,1844,1843,2077,2085,2437,2443,2448,2449,2450,2451,2028,2032,2412,1992,1983,1984,2482,1995,1998,1850,1851,1865,1861,1866,3666,397,3666,397,3649,365,3639,365,3639,365,3623,365,3649,366,3623,187,366,190,187,190,731,98};
        int BoundaryVertex1[] = {3428,2206,2246,3430,3436,3433,2203,2194,3374,3396,3401,3359,3351,3331,3328,3296,3285,1897,1898,2274,2275,1960,2273,2272,2285,2281,2215,2217,28,562,515,678,708,96,98,642,99,643,191,188,295,1726,294,1742,327,1752,326,1769,728,421,297,245,1776,186,181,563,147,130,125,129,115,114,224,221,652,653,252,281,250,118,119,626,625,624,623,618,278,270,107,108,234,216,217,231,703,527,219,23,3408,3413,3410,3409,1966,1965,1954,3440,3439,3447,3448,3473,3474,3454,3455,3457,3484,3483,3485,3480,3462,3463,3451,1946,1945,1808,1807,1983,1997,2011};
        for( size_t i = 0; i<sizeof(BoundaryVertex1)/sizeof(*BoundaryVertex1); i++ )
        {
            BoundaryVertex_vec.push_back(BoundaryVertex1[i]);
        }
    }
    else if(deform_times==2)
    {
//        int BoundaryVertex2[] = {3643,593,3628,104,687,688,689,690,44,2427,2426,2425,2424,1841,3617,2330,3607,2499,3595,2497,2496,2489,3573,2492,2438,2437,2469,2473,2332,2333,2415,2300,2304,35,567,563,678,596,595,736,732,700,701,755,3657,752,759,760,3655,762};
        int BoundaryVertex2[] = {1746,518,1731,105,610,611,612,613,44,1800,1799,2244,3284,3304,3303,3322,3337,3355,3365,3407,3404,3405,3445,3443,3444,3473,3471,3469,3493,3491,2014,2016,35,492,488,602,521,520,491,618,619,661,1760,658,665,666,1758,668};
        for( size_t i = 0; i<sizeof(BoundaryVertex2)/sizeof(*BoundaryVertex2); i++ )
        {
            BoundaryVertex_vec.push_back(BoundaryVertex2[i]);
        }
    }
    else if(deform_times==3)
    {
        int BoundaryVertex3[] = {349,303,115,113,112,301,817,671,681,343,563,737,738,739,605,606,340,337,755,754,562,756,757,779,357,276,349,2080,737,754};
        for( size_t i = 0; i<sizeof(BoundaryVertex3)/sizeof(*BoundaryVertex3); i++ )
        {
            BoundaryVertex_vec.push_back(BoundaryVertex3[i]);
        }
    }
    else if(deform_times==4)
    {
//        int BoundaryVertex4[] = {125,288,289,584,574,585,40,2322,2311,2321,2026,2025,1862,2069,1861,1866,1883,2375,1917,1922,3680,2022,2105,2229,2560,3582,2134,3589,2135,3603,2102,3611,2103,1924,1927,2468,1835,1834,1832,2540,2509,2327,2374,28,637,590,772,803,95,97,98,731,190,187,366,3623,365,3639,398,3649,397,3666,823,492,368,285,3678,185,180,638,146,129,124,332,125,2069,1883,823,3649,823,3649};
        int BoundaryVertex4[] = {2207,2201,2202,2255,1964,1823,1821,1997,2011,3428,2206,2246,3430,3436,3433,2203,2194,3374,3396,3401,3359,3351,3331,3328,3296,3285,1897,1898,2274,2275,2273,2272,2285,2281,2215,2217,28,562,515,678,708,96,98,99,643,191,188,295,1726,294,1742,327,1752,326,1769,728,421,297,245,1776,186,181,563,147,130,125,262,126,248,249,509,499,510,40};
        for( size_t i = 0; i<sizeof(BoundaryVertex4)/sizeof(*BoundaryVertex4); i++ )
        {
            BoundaryVertex_vec.push_back(BoundaryVertex4[i]);
        }
    }
    const int BV_size = BoundaryVertex_vec.size();
    int BoundaryVertex[BV_size];
    for( size_t i = 0; i<BoundaryVertex_vec.size(); i++ )
    {
        BoundaryVertex[i] = BoundaryVertex_vec[i];
    }
    // Boundary equals false, internal equals true (vertex)
    for( size_t i = 0; i<sizeof(BoundaryVertex)/sizeof(*BoundaryVertex); i++ )
    {
        isUse[BoundaryVertex[i]] = false;
    }
    // Set interV
    for( size_t i = 0; i<isUse.size(); i++ )
    {
        if( isUse[i] )
        {
            interV.push_back(i);
        }
    }
}

void OpenMeshObject::CalculateMoveFeatures()
{
    // Clear
    FaceFeatures.clear();
    // Features (All points)
    std::vector< BaseMesh::Point >OriFeatures;
    std::vector< BaseMesh::Point >DefFeatures;
    int allFeatures[] = {/*face*/1,3,3,1,2,2,3,2,3,2,2,1,3,3,1,/*nose*/1,1,1,1,2,1,1,1,1,/*left_e*/1,1,1,1,1,1,1,1,/*right_e*/1,1,1,1,1,1,1,1,/*mouth*/1,4,1,3,1,4,1,2,1,1,1,2};
    // original features
    int start = 0;
    for( size_t i = 0; i<sizeof(allFeatures)/sizeof(*allFeatures); i++ )
    {
        if( allFeatures[i] != 0 )
        {
            BaseMesh::Point pos(0,0,0);
            for( int j = 0; j<allFeatures[i]; j++ )
            {
                pos.data()[0] += control_pts[start + j].data()[0];
                pos.data()[1] += control_pts[start + j].data()[1];
            }
            // 3D
            pos.data()[0] = pos.data()[0] / allFeatures[i];
            pos.data()[1] = pos.data()[1] / allFeatures[i];
            pos.data()[2] = 0;
            OriFeatures.push_back(pos);
        }
        start += allFeatures[i];
    }
    // deform features
    float fhs[] = {//face
                   static_cast<float>(m_featurePos[0]), static_cast<float>(m_featurePos[1]),
                   static_cast<float>(m_featurePos[2]), static_cast<float>(m_featurePos[3]),
                   static_cast<float>(m_featurePos[4]), static_cast<float>(m_featurePos[5]),
                   static_cast<float>(m_featurePos[6]), static_cast<float>(m_featurePos[7]),
                   static_cast<float>(m_featurePos[8]), static_cast<float>(m_featurePos[9]),
                   static_cast<float>(m_featurePos[10]), static_cast<float>(m_featurePos[11]),
                   static_cast<float>(m_featurePos[12]), static_cast<float>(m_featurePos[13]),
                   static_cast<float>(m_featurePos[14]), static_cast<float>(m_featurePos[15]),
                   static_cast<float>(m_featurePos[16]), static_cast<float>(m_featurePos[17]),
                   static_cast<float>(m_featurePos[18]), static_cast<float>(m_featurePos[19]),
                   static_cast<float>(m_featurePos[20]), static_cast<float>(m_featurePos[21]),
                   static_cast<float>(m_featurePos[22]), static_cast<float>(m_featurePos[23]),
                   static_cast<float>(m_featurePos[24]), static_cast<float>(m_featurePos[25]),
                   static_cast<float>(m_featurePos[26]), static_cast<float>(m_featurePos[27]),
                   static_cast<float>(m_featurePos[28]), static_cast<float>(m_featurePos[29]),
                   //nose
                   static_cast<float>(m_featurePos[68]), static_cast<float>(m_featurePos[69]),
                   static_cast<float>(m_featurePos[70]), static_cast<float>(m_featurePos[71]),
                   static_cast<float>(m_featurePos[72]), static_cast<float>(m_featurePos[73]),
                   static_cast<float>(m_featurePos[84]), static_cast<float>(m_featurePos[85]),
                   static_cast<float>(m_featurePos[74]), static_cast<float>(m_featurePos[75]),
                   static_cast<float>(m_featurePos[86]), static_cast<float>(m_featurePos[87]),
                   static_cast<float>(m_featurePos[76]), static_cast<float>(m_featurePos[77]),
                   static_cast<float>(m_featurePos[78]), static_cast<float>(m_featurePos[79]),
                   static_cast<float>(m_featurePos[80]), static_cast<float>(m_featurePos[81]),
                  //left eye
                   static_cast<float>(m_featurePos[46]), static_cast<float>(m_featurePos[47]),
                   static_cast<float>(m_featurePos[132]), static_cast<float>(m_featurePos[133]),
                   static_cast<float>(m_featurePos[52]), static_cast<float>(m_featurePos[53]),
                   static_cast<float>(m_featurePos[130]), static_cast<float>(m_featurePos[131]),
                   static_cast<float>(m_featurePos[50]), static_cast<float>(m_featurePos[51]),
                   static_cast<float>(m_featurePos[128]), static_cast<float>(m_featurePos[129]),
                   static_cast<float>(m_featurePos[48]), static_cast<float>(m_featurePos[49]),
                   static_cast<float>(m_featurePos[126]), static_cast<float>(m_featurePos[127]),
                  //right eye
                   static_cast<float>(m_featurePos[56]), static_cast<float>(m_featurePos[57]),
                   static_cast<float>(m_featurePos[140]), static_cast<float>(m_featurePos[141]),
                   static_cast<float>(m_featurePos[62]), static_cast<float>(m_featurePos[63]),
                   static_cast<float>(m_featurePos[138]), static_cast<float>(m_featurePos[139]),
                   static_cast<float>(m_featurePos[60]), static_cast<float>(m_featurePos[61]),
                   static_cast<float>(m_featurePos[136]), static_cast<float>(m_featurePos[137]),
                   static_cast<float>(m_featurePos[58]), static_cast<float>(m_featurePos[59]),
                   static_cast<float>(m_featurePos[134]), static_cast<float>(m_featurePos[135]),
                   //mouth
                   static_cast<float>(m_featurePos[88]), static_cast<float>(m_featurePos[89]),
                   static_cast<float>(m_featurePos[90]), static_cast<float>(m_featurePos[91]),
                   static_cast<float>(m_featurePos[92]), static_cast<float>(m_featurePos[93]),
                   static_cast<float>(m_featurePos[94]), static_cast<float>(m_featurePos[95]),
                   static_cast<float>(m_featurePos[96]), static_cast<float>(m_featurePos[97]),
                   static_cast<float>(m_featurePos[98]), static_cast<float>(m_featurePos[99]),
                   static_cast<float>(m_featurePos[100]), static_cast<float>(m_featurePos[101]),
                   static_cast<float>(m_featurePos[102]), static_cast<float>(m_featurePos[103]),
                   static_cast<float>(m_featurePos[104]), static_cast<float>(m_featurePos[105]),
                   static_cast<float>(m_featurePos[106]), static_cast<float>(m_featurePos[107]),
                   static_cast<float>(m_featurePos[108]), static_cast<float>(m_featurePos[109]),
                   static_cast<float>(m_featurePos[110]), static_cast<float>(m_featurePos[111])};
    // Set FaceFeatures
    std::vector< BaseMesh::Point > PointsData;
    for(size_t i = 0; i<sizeof(fhs)/sizeof(*fhs); i=i+2)
    {
        BaseMesh::Point fp;
        fp.data()[0] = fhs[i];
        fp.data()[1] = fhs[i+1];
        fp.data()[2] = 0;
        PointsData.push_back(fp);
    }
    // 2D FaceFeatures position in the image
    pos_facefeatures = PointsData;
    // Set DefFeatures
    DefFeatures.clear();
    DefFeatures = OriFeatures;
    // Mid point
    float mid_ox = (OriFeatures[14].data()[0] + OriFeatures[0].data()[0])/2;
    float mid_oy = (OriFeatures[14].data()[1] + OriFeatures[0].data()[1])/2;
    float mid_x = (PointsData[14].data()[0] + PointsData[0].data()[0])/2;
    float mid_y = (PointsData[14].data()[1] + PointsData[0].data()[1])/2;
    // Compute corresponding bias
    std::vector< float > width_ox, height_oy;
    std::vector< float > width_x, height_y;
    for( size_t i = 0; i<OriFeatures.size(); i++ )
    {
        // Original
        float value_ox = mid_ox - OriFeatures[i].data()[0];
        width_ox.push_back(fabs(value_ox));
        float value_oy = mid_oy - OriFeatures[i].data()[1];
        height_oy.push_back(fabs(value_oy));
        // Deform
        float value_x = mid_x - PointsData[i].data()[0];
        width_x.push_back(fabs(value_x));
        float value_y = mid_y - PointsData[i].data()[1];
        height_y.push_back(fabs(value_y));
    }
    // Scale
    float face_scale = (width_ox[0] / width_x[0] + width_ox[14] / width_x[14]) / 2;
    // Compute face bias (0~14)
    for( int i = 1; i<15; i++ )
    {
        // Compute x-coordinate
        DefFeatures[i].data()[0] = width_x[i] * face_scale;
        if( mid_ox - OriFeatures[i].data()[0]<0 )
        {
            DefFeatures[i].data()[0] = mid_ox + DefFeatures[i].data()[0];
        }
        else
        {
            DefFeatures[i].data()[0] = mid_ox - DefFeatures[i].data()[0];
        }
        // Compute y-coordinate
        DefFeatures[i].data()[1] = height_y[i] * face_scale;
        DefFeatures[i].data()[1] = mid_oy - DefFeatures[i].data()[1];
    }
    // Compute nose bias (15~23)
    for(int i = 15;i<24;i++)
    {
        // Compute x-coordinate
        DefFeatures[i].data()[0] = width_x[i] * face_scale;
        if( mid_ox - OriFeatures[i].data()[0]<0 )
        {
            DefFeatures[i].data()[0] = mid_ox + DefFeatures[i].data()[0];
        }
        else
        {
            DefFeatures[i].data()[0] = mid_ox - DefFeatures[i].data()[0];
        }
        // Compute y-coordinate
        DefFeatures[i].data()[1] = height_y[i] * face_scale;
        DefFeatures[i].data()[1] = mid_oy - DefFeatures[i].data()[1];
    }
    // Compute left eyes bias (24~31)
    for(int i = 24;i<32;i++)
    {
        // Compute x-coordinate
        DefFeatures[i].data()[0] = width_x[i] * face_scale;
        if( mid_ox - OriFeatures[i].data()[0]<0 )
        {
            DefFeatures[i].data()[0] = mid_ox + DefFeatures[i].data()[0];
        }
        else
        {
            DefFeatures[i].data()[0] = mid_ox - DefFeatures[i].data()[0];
        }
        // Compute y-coordinate
        DefFeatures[i].data()[1] = height_y[i] * face_scale;
        if( mid_y - PointsData[i].data()[1]>0 )
        {
            DefFeatures[i].data()[1] = mid_oy + DefFeatures[i].data()[1];
        }
        else
        {
            DefFeatures[i].data()[1] = mid_oy - DefFeatures[i].data()[1];
        }
    }
    // Compute right eyes bias (32~39)
    for(int i = 32;i<40;i++)
    {
        // Compute x-coordinate
        DefFeatures[i].data()[0] = width_x[i] * face_scale;
        if( mid_ox - OriFeatures[i].data()[0]<0 )
        {
            DefFeatures[i].data()[0] = mid_ox + DefFeatures[i].data()[0];
        }
        else
        {
            DefFeatures[i].data()[0] = mid_ox - DefFeatures[i].data()[0];
        }
        // Compute y-coordinate
        DefFeatures[i].data()[1] = height_y[i] * face_scale;
        if( mid_y - PointsData[i].data()[1]>0 )
        {
            DefFeatures[i].data()[1] = mid_oy + DefFeatures[i].data()[1];
        }
        else
        {
            DefFeatures[i].data()[1] = mid_oy - DefFeatures[i].data()[1];
        }
    }
    // Compute mouth bias (40~51)
    for(int i = 40;i<52;i++)
    {
        // Compute x-coordinate
        DefFeatures[i].data()[0] = width_x[i] * face_scale;
        if(mid_ox - OriFeatures[i].data()[0]<0)
        {
            DefFeatures[i].data()[0] = mid_ox + DefFeatures[i].data()[0];
        }
        else
        {
            DefFeatures[i].data()[0] = mid_ox - DefFeatures[i].data()[0];
        }
        // Compute y-coordinate
        DefFeatures[i].data()[1] = height_y[i] * face_scale;
        DefFeatures[i].data()[1] = mid_oy - DefFeatures[i].data()[1];
    }
    // mid point return to mid
    int mid_p[] = {7,19,43,49};
    for( size_t i = 0; i<sizeof(mid_p)/sizeof(*mid_p); i++ )
    {
        DefFeatures[mid_p[i]].data()[0] = (DefFeatures[mid_p[i]-1].data()[0] + DefFeatures[mid_p[i]+1].data()[0]) / 2;
    }
    // Set FeaturesData
    std::vector< Eigen::RowVector3d > FeaturesData;
    Eigen::RowVector3d pos;
    for(size_t i = 0;i<OriFeatures.size();i++)
    {
        // Give bias value
        float moveBiasX = 0, moveBiasY = 0;
        if(i>0 && i<14)
        {
            float c = 0;
            if(i==1 || i==13)
            {
                c += 0.02;
            }
            else if(i==2 || i==12)
            {
                c += 0.045;
            }
            else if(i==3 || i==11)
            {
                c += 0.03;
            }
            else if(i==4 || i==10)
            {
                //c -= 0.005;
            }
            else if(i==5 || i==9)
            {
                //c += 0.025;
                c += 0.005;
            }
            else if(i==6 || i==8)
            {
                //c += 0.005;
                //c -= 0.025;
                c -= 0.0275;
            }
            else if(i==7)
            {
                //c -= 0.01;
                //c -= 0.040;
                c -= 0.0425;
            }
            moveBiasX = width_x[i] * face_scale * c;
            if(mid_ox - OriFeatures[i].data()[0]<0)
            {
                moveBiasX *= 1;
            }
            else
            {
                moveBiasX *= -1;
            }
            moveBiasY = height_y[i] * face_scale * c;
            moveBiasY *= -1;
        }
        if(i>23 && i<40)
        {
            float c = 0;
            c += 0.04;
            moveBiasY = height_y[i] * face_scale * c;
            moveBiasY *= -1;
        }
        // Compute pos
        if(i>14 && i<24)
        {
            // Nose
            float c = 0;
            c += 0.02;
            moveBiasX = width_x[i] * face_scale * c;
            if(mid_ox - OriFeatures[i].data()[0]<0)
            {
                moveBiasX *= 1;
            }
            else
            {
                moveBiasX *= -1;
            }
            pos(0,0) = -(OriFeatures[i].data()[0] - DefFeatures[i].data()[0] - moveBiasX);
        }
        else
        {
            // Others
            pos(0,0) = -(OriFeatures[i].data()[0] - DefFeatures[i].data()[0] - moveBiasX);
        }
        pos(0,1) = -(OriFeatures[i].data()[1] - DefFeatures[i].data()[1] - moveBiasY);
        pos(0,2) = 0;
        FeaturesData.push_back(pos);
    }
    // Set Face Features
    for( size_t i = 0; i<OriFeatures.size(); i++ )
    {
        for( int j = 0; j<allFeatures[i]; j++ )
        {
            FaceFeatures.push_back(FeaturesData[i]);
        }
    }
    // Move Mouth control points for the upper of mouth (57,58,59,60,62,64,66,67,68,69)
    Eigen::RowVector3d FF;
    int mouth_df_lr[] = {41,45};
    int mouth_c_lr[] = {58,67};
    for( size_t i = 0; i<sizeof(mouth_df_lr)/sizeof(*mouth_df_lr); i++ )
    {
        Eigen::RowVector3d p1(DefFeatures[mouth_df_lr[i]-1].data()[0],DefFeatures[mouth_df_lr[i]-1].data()[1],control_pts[mouth_c_lr[i]].data()[2]);
        Eigen::RowVector3d p2(DefFeatures[mouth_df_lr[i]+1].data()[0],DefFeatures[mouth_df_lr[i]+1].data()[1],control_pts[mouth_c_lr[i]+5].data()[2]);
        int _length = allFeatures[41];
        for( int n = 1; n<=_length; n++ )
        {
            for( int j = 0; j<3; j++)
            {
                FF(j) = p1(j)*(_length+1-n)/(_length+1) + p2(j)*n/(_length+1);
            }
            for( int j = 0; j<3; j++ )
                FaceFeatures[mouth_c_lr[i]+n](j) = FF(j) - control_pts[mouth_c_lr[i]+n].data()[j];
        }
    }
    int mouth_df[] = {42,43};
    int mouth_c[] = {64,66};
    for( size_t i = 0; i<sizeof(mouth_df)/sizeof(*mouth_df); i++ )
    {
        Eigen::RowVector3d p3(DefFeatures[mouth_df[i]].data()[0],DefFeatures[mouth_df[i]].data()[1]+FeaturesData[mouth_c[i]-1](1),control_pts[mouth_c[i]-1].data()[2]);
        Eigen::RowVector3d p4(DefFeatures[mouth_df[i]+1].data()[0],DefFeatures[mouth_df[i]+1].data()[1]+FeaturesData[mouth_c[i]+1](1),control_pts[mouth_c[i]+1].data()[2]);
        FF = (p3+p4)/2;
        for( int j = 0; j<3; j++ )
            FaceFeatures[mouth_c[i]](j) = FF(j) - control_pts[mouth_c[i]].data()[j];
    }
    // Move (58~72)
    float moveBiasY = 0, ff_idx = 43, c = 0.04;
    moveBiasY = height_y[ff_idx] * face_scale * c;
    moveBiasY *= -1;
    for( int i = 58; i<73; i++ )
    {
        FaceFeatures[i](1) += moveBiasY;
    }
}

void OpenMeshObject::InitMatrix()
{
    const int n = mesh.n_vertices();
    const int m = mesh.n_faces();
    // All vertices
    V.resize(n,3);
    for ( BaseMesh::VertexIter v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it )
    {
        V(v_it->idx(),0) = mesh.point(*v_it).data()[0];
        V(v_it->idx(),1) = mesh.point(*v_it).data()[1];
        V(v_it->idx(),2) = mesh.point(*v_it).data()[2];
    }
    // Set U
    U = V;
    // All faces
    F.resize(m,3);
    for ( BaseMesh::FaceIter f_it = mesh.faces_begin(); f_it != mesh.faces_end(); ++f_it )
    {
        int count = 0;
        for ( BaseMesh::FaceVertexIter fv_it = mesh.fv_iter(*f_it); fv_it.is_valid(); ++fv_it )
        {
            count += 1;
            if (count == 1)
            {
                F(f_it->idx(),0) = fv_it->idx();
            }
            if (count == 2)
            {
                F(f_it->idx(),1) = fv_it->idx();
            }
            if (count == 3)
            {
                F(f_it->idx(),2) = fv_it->idx();
            }
        }
    }
    // S(i) = j: j < 0 (vertex i not in handle), j >= 0 (vertex i in handle j)
    Eigen::VectorXi S;
    S.resize(n);
    //initialize to 0
    for( int i = 0; i<n; i++ )
    {
        S(i) = 0;
    }
    int b_size = n;
    //deform_times++;
    int deform_part[] = {0,32,42,58,80};
    //int interV_size = 983;
    for( size_t i = 0; i<interV.size()+control_pts.size(); i++ )
    {
        if(i < interV.size())
        {
            S(interV[i],0) = -1;
            b_size--;
        }
        else
        {
            if(deform_times<4)
            {
                if(i-interV.size()>=deform_part[deform_times-1] && i-interV.size()<deform_part[deform_times])
                {
                    S(control_pts_VH[i-interV.size()].idx(),0) = 1;
                    b_size++;
                }
                if(deform_times==2)
                {
                    if(i-interV.size()>=deform_part[deform_times+1] && i-interV.size()<deform_part[deform_times+2])
                    {
                        S(control_pts_VH[i-interV.size()].idx(),0) = 1;
                        b_size++;
                    }
                }
            }
            else
            {
                S(control_pts_VH[i-interV.size()].idx(),0) = 1;
                b_size++;
            }
        }
    }
    // Set Matrix b (fix and edit vertexes index) (S >= 0)
    b.resize(b_size);
    int b_index = 0;
    for( int i = 0; i<S.size(); i++ )
    {
        if( S(i)>=0 )
        {
            b(b_index) = i;
            b_index++;
        }
    }
    // Boundary conditions directly on deformed positions
    U_bc.resize(b.size(),V.cols());
    V_bc.resize(b.size(),V.cols());
    for(int bi = 0;bi<b.size();bi++)
    {
        V_bc.row(bi) = V.row(b(bi));
        switch(S(b(bi)))
        {
        case 0:
            // Don't move handle 0
            U_bc.row(bi) = V.row(b(bi));
            break;
        case 1:
            // move handle 1 (x+ right x- left)
            if(FaceFeatures.size()!=0)
            {
                bool isExist = false;
                if(deform_times<4)
                {
                    for(size_t i = 0;i<control_pts_VH.size();i++)
                    {
                        if(control_pts_VH[i].idx() == b(bi))
                        {
                            isExist = true;
                            U_bc.row(bi) = V.row(b(bi)) + FaceFeatures[i];
                            break;
                        }
                    }
                }
                if(deform_times>3)
                    isExist = false;
                if(isExist == false)
                {
                    U_bc.row(bi) = V.row(b(bi)) + Eigen::RowVector3d(0, 0, 0);
                }
            }
            else
            {
                //U_bc.row(bi) = V.row(b(bi)) + Eigen::RowVector3d(0, -0.01f, 0);
                U_bc.row(bi) = V.row(b(bi)) + Eigen::RowVector3d(0, 0, 0);
            }
            break;
        default:
            // move other handles
            U_bc.row(bi) = V.row(b(bi)) + Eigen::RowVector3d(0, 0, -25);
            break;
        }
    }
}

void OpenMeshObject::Deform()
{
    const Eigen::MatrixXd U_bc_anim = V_bc + bc_frac * (U_bc-V_bc);
    harmonic(V,F,b,U_bc_anim,2,U);
    // Set U to the mesh vertexes
    for (BaseMesh::VertexIter v_it = mesh.vertices_begin(); v_it != mesh.vertices_end(); ++v_it)
    {
        mesh.point(*v_it).data()[0] = U(v_it->idx(),0);
        mesh.point(*v_it).data()[1] = U(v_it->idx(),1);
        mesh.point(*v_it).data()[2] = U(v_it->idx(),2);
    }
}

template <typename DerivedV, typename DerivedF, typename Derivedb, typename Derivedbc, typename DerivedW>
bool OpenMeshObject::harmonic(
    const Eigen::PlainObjectBase<DerivedV> & V,
    const Eigen::PlainObjectBase<DerivedF> & F,
    const Eigen::PlainObjectBase<Derivedb> & b,
    const Eigen::PlainObjectBase<Derivedbc> & bc,
    const int k,
    Eigen::PlainObjectBase<DerivedW> & W)
{
    typedef typename DerivedV::Scalar Scalar;
    typedef Eigen::Matrix<Scalar,Eigen::Dynamic,1> VectorXS;
    Eigen::SparseMatrix<Scalar> L,M,Mi;
    cotmatrix(V,F,L);
    //Triangle Mesh - MASSMATRIX_TYPE_VORONOI
    massmatrix(V,F,M);
    invert_diag(M,Mi);
    Eigen::SparseMatrix<Scalar> Q = -L;
    for(int p = 1;p<k;p++)
    {
        Q = (Q*Mi*-L).eval();
    }
    const VectorXS B = VectorXS::Zero(V.rows(),1);
    min_quad_with_fixed_data<Scalar> data;
    min_quad_with_fixed_precompute(Q,b,Eigen::SparseMatrix<Scalar>(),true,data);
    W.resize(V.rows(),bc.cols());
    for(int w = 0;w<bc.cols();w++)
    {
        const VectorXS bcw = bc.col(w);
        VectorXS Ww;
        if(!min_quad_with_fixed_solve(data,B,bcw,VectorXS(),Ww))
        {
            return false;
        }
        W.col(w) = Ww;
    }
    return true;
}

template <typename DerivedV, typename DerivedF, typename ScalarS>
void OpenMeshObject::cotmatrix(
    const Eigen::PlainObjectBase<DerivedV> & V,
    const Eigen::PlainObjectBase<DerivedF> & F,
    Eigen::SparseMatrix<ScalarS>& L)
{
    L.resize(V.rows(),V.rows());
    Eigen::Matrix<int,Eigen::Dynamic,2> edges;
    int simplex_size = F.cols();
    // 3 for triangles
    if(simplex_size == 3)
    {
        // This is important! it could decrease the comptuation time by a factor of 2
        // Laplacian for a closed 2d manifold mesh will have on average 7 entries per
        // row
        L.reserve(10*V.rows());
        edges.resize(3,2);
        edges <<
            1,2,
            2,0,
            0,1;
    }else
    {
        return;
    }
    // Gather cotangents
    Eigen::Matrix<ScalarS,Eigen::Dynamic,Eigen::Dynamic> C;
    cotmatrix_entries(V,F,C);

    std::vector<Eigen::Triplet<ScalarS> > IJV;
    IJV.reserve(F.rows()*edges.rows()*4);
    // Loop over triangles
    for(int i = 0; i < F.rows(); i++)
    {
        // loop over edges of element
        for(int e = 0;e<edges.rows();e++)
        {
            int source = F(i,edges(e,0));
            int dest = F(i,edges(e,1));
            IJV.push_back(Eigen::Triplet<ScalarS>(source,dest,C(i,e)));
            IJV.push_back(Eigen::Triplet<ScalarS>(dest,source,C(i,e)));
            IJV.push_back(Eigen::Triplet<ScalarS>(source,source,-C(i,e)));
            IJV.push_back(Eigen::Triplet<ScalarS>(dest,dest,-C(i,e)));
        }
    }
    L.setFromTriplets(IJV.begin(),IJV.end());
}

template <typename DerivedV, typename DerivedF, typename DerivedC>
void OpenMeshObject::cotmatrix_entries(
    const Eigen::PlainObjectBase<DerivedV>& V,
    const Eigen::PlainObjectBase<DerivedF>& F,
    Eigen::PlainObjectBase<DerivedC>& C)
{
    // simplex size (3: triangles, 4: tetrahedra)
    int simplex_size = F.cols();
    // Number of elements
    int m = F.rows();

    // Law of cosines + law of sines
    switch(simplex_size)
    {
        case 3:
        {
            // Triangles
            //Matrix<typename DerivedC::Scalar,Dynamic,3> l;
            //edge_lengths(V,F,l);
            // edge lengths numbered same as opposite vertices
            Eigen::Matrix<typename DerivedC::Scalar,Eigen::Dynamic,3> l;
            edge_lengths(V,F,l);
            // double area
            Eigen::Matrix<typename DerivedC::Scalar,Eigen::Dynamic,1> dblA;
            doublearea(l,dblA);
            // cotangents and diagonal entries for element matrices
            // correctly divided by 4 (alec 2010)
            C.resize(m,3);
            for(int i = 0;i<m;i++)
            {
                C(i,0) = (l(i,1)*l(i,1) + l(i,2)*l(i,2) - l(i,0)*l(i,0))/dblA(i)/4.0;
                C(i,1) = (l(i,2)*l(i,2) + l(i,0)*l(i,0) - l(i,1)*l(i,1))/dblA(i)/4.0;
                C(i,2) = (l(i,0)*l(i,0) + l(i,1)*l(i,1) - l(i,2)*l(i,2))/dblA(i)/4.0;
            }
            break;
        }
        default:
        {
            fprintf(stderr,
                "cotmatrix_entries.h: Error: Simplex size (%d) not supported\n", simplex_size);
        }
    }
}

template <typename DerivedV, typename DerivedF, typename DerivedL>
void OpenMeshObject::edge_lengths(
    const Eigen::PlainObjectBase<DerivedV>& V,
    const Eigen::PlainObjectBase<DerivedF>& F,
    Eigen::PlainObjectBase<DerivedL>& L)
{
    switch(F.cols())
    {
    case 2:
        {
            L.resize(F.rows(),1);
            for(int i = 0;i<F.rows();i++)
            {
                L(i,0) = (V.row(F(i,1))-V.row(F(i,0))).norm();
            }
            break;
        }
    case 3:
        {
            L.resize(F.rows(),3);
            // loop over faces
            for(int i = 0;i<F.rows();i++)
            {
                L(i,0) = sqrt((V.row(F(i,1))-V.row(F(i,2))).array().pow(2).sum());
                L(i,1) = sqrt((V.row(F(i,2))-V.row(F(i,0))).array().pow(2).sum());
                L(i,2) = sqrt((V.row(F(i,0))-V.row(F(i,1))).array().pow(2).sum());
            }
            break;
        }
    case 4:
        {
            const int m = F.rows();
            L.resize(m,6);
            // loop over faces
            for(int i = 0;i<m;i++)
            {
                L(i,0) = sqrt((V.row(F(i,3))-V.row(F(i,0))).array().pow(2).sum());
                L(i,1) = sqrt((V.row(F(i,3))-V.row(F(i,1))).array().pow(2).sum());
                L(i,2) = sqrt((V.row(F(i,3))-V.row(F(i,2))).array().pow(2).sum());
                L(i,3) = sqrt((V.row(F(i,1))-V.row(F(i,2))).array().pow(2).sum());
                L(i,4) = sqrt((V.row(F(i,2))-V.row(F(i,0))).array().pow(2).sum());
                L(i,5) = sqrt((V.row(F(i,0))-V.row(F(i,1))).array().pow(2).sum());
            }
            break;
        }
    default:
        {
            std::cerr<< "edge_lengths.h: Error: Simplex size ("<<F.cols()<<") not supported"<<endl;
        }
    }
}

template <typename Derivedl, typename DeriveddblA>
void OpenMeshObject::doublearea(
    const Eigen::PlainObjectBase<Derivedl> & ul,
    Eigen::PlainObjectBase<DeriveddblA> & dblA)
{
    // Number of triangles
    const int m = ul.rows();
    Eigen::PlainObjectBase<Derivedl> l;
    Eigen::MatrixXi _;
    sort(ul,2,false,l,_);
    // semiperimeters
    Eigen::Matrix<typename Derivedl::Scalar,Eigen::Dynamic,1> s = l.rowwise().sum()*0.5;
    // resize output
    dblA.resize(l.rows(),1);
    for(int i = 0;i<m;i++)
    {
        //// Heron's formula for area
        //const typename Derivedl::Scalar arg =
        //  s(i)*(s(i)-l(i,0))*(s(i)-l(i,1))*(s(i)-l(i,2));
        //assert(arg>=0);
        //dblA(i) = 2.0*sqrt(arg);
        // Kahan's Heron's formula
        const typename Derivedl::Scalar arg =
            (l(i,0)+(l(i,1)+l(i,2)))*
            (l(i,2)-(l(i,0)-l(i,1)))*
            (l(i,2)+(l(i,0)-l(i,1)))*
            (l(i,0)+(l(i,1)-l(i,2)));
        dblA(i) = 2.0*0.25*sqrt(arg);
    }
}

template <typename DerivedX, typename DerivedIX>
void OpenMeshObject::sort(
    const Eigen::PlainObjectBase<DerivedX>& X,
    const int dim,
    const bool ascending,
    Eigen::PlainObjectBase<DerivedX>& Y,
    Eigen::PlainObjectBase<DerivedIX>& IX)
{
    // get number of rows (or columns)
    int num_inner = (dim == 1 ? X.rows() : X.cols() );
    // get number of columns (or rows)
    int num_outer = (dim == 1 ? X.cols() : X.rows() );
    // dim must be 2 or 1
    assert(dim == 1 || dim == 2);
    // Resize output
    Y.resize(X.rows(),X.cols());
    IX.resize(X.rows(),X.cols());
    // idea is to process each column (or row) as a std vector
    // loop over columns (or rows)
    for(int i = 0; i<num_outer;i++)
    {
        // Unsorted index map for this column (or row)
        std::vector<size_t> index_map(num_inner);
        std::vector<double> data(num_inner);
        for(int j = 0;j<num_inner;j++)
        {
            if(dim == 1)
            {
                data[j] = (double) X(j,i);
            }else
            {
                data[j] = (double) X(i,j);
            }
        }
        // sort this column (or row)
        sort( data, ascending, data, index_map);
        // Copy into Y and IX
        for(int j = 0;j<num_inner;j++)
        {
            if(dim == 1)
            {
                Y(j,i) = data[j];
                IX(j,i) = index_map[j];
            }else
            {
                Y(i,j) = data[j];
                IX(i,j) = index_map[j];
            }
        }
    }
}

template <class T>
void OpenMeshObject::sort(
    const std::vector<T> & unsorted,
    const bool ascending,
    std::vector<T> & sorted,
    std::vector<size_t> & index_map)
{
    // Original unsorted index map
    index_map.resize(unsorted.size());
    for(size_t i=0;i<unsorted.size();i++)
    {
        index_map[i] = i;
    }
    // Sort the index map, using unsorted for comparison
    std::sort(
        index_map.begin(),
        index_map.end(),
        OpenMeshObject::IndexLessThan<const std::vector<T>& >(unsorted));

    // if not ascending then reverse
    if(!ascending)
    {
        std::reverse(index_map.begin(),index_map.end());
    }
    // make space for output without clobbering
    sorted.resize(unsorted.size());
    // reorder unsorted into sorted using index map
    reorder(unsorted,index_map,sorted);
}

// This implementation is O(n), but also uses O(n) extra memory
template< class T >
void OpenMeshObject::reorder(
    const std::vector<T> & unordered,
    std::vector<size_t> const & index_map,
    std::vector<T> & ordered)
{
    // copy for the reorder according to index_map, because unsorted may also be
    // sorted
    std::vector<T> copy = unordered;
    ordered.resize(index_map.size());
    for(int i = 0; i<(int)index_map.size();i++)
    {
        ordered[i] = copy[index_map[i]];
    }
}

template <typename DerivedV, typename DerivedF, typename ScalarS>
void OpenMeshObject::massmatrix(
    const Eigen::MatrixBase<DerivedV> & V,
    const Eigen::MatrixBase<DerivedF> & F,
    Eigen::SparseMatrix<ScalarS>& M)
{
    const int n = V.rows();
    const int m = F.rows();

    Eigen::Matrix<int,Eigen::Dynamic,1> MI;
    Eigen::Matrix<int,Eigen::Dynamic,1> MJ;
    Eigen::Matrix<ScalarS,Eigen::Dynamic,1> MV;

    // Triangles
    // edge lengths numbered same as opposite vertices
    Eigen::Matrix<ScalarS,Eigen::Dynamic,3> l(m,3);
    // loop over faces
    for(int i = 0;i<m;i++)
    {
        l(i,0) = sqrt((V.row(F(i,1))-V.row(F(i,2))).array().pow(2).sum());
        l(i,1) = sqrt((V.row(F(i,2))-V.row(F(i,0))).array().pow(2).sum());
        l(i,2) = sqrt((V.row(F(i,0))-V.row(F(i,1))).array().pow(2).sum());
    }
    // semiperimeters
    Eigen::Matrix<ScalarS,Eigen::Dynamic,1> s = l.rowwise().sum()*0.5;
    // Heron's forumal for area
    Eigen::Matrix<ScalarS,Eigen::Dynamic,1> dblA(m);
    for(int i = 0;i<m;i++)
    {
        dblA(i) = 2.0*sqrt(s(i)*(s(i)-l(i,0))*(s(i)-l(i,1))*(s(i)-l(i,2)));
    }

    //case MASSMATRIX_TYPE_VORONOI:
    // diagonal entries for each face corner
    // http://www.alecjacobson.com/weblog/?p=874
    MI.resize(m*3,1); MJ.resize(m*3,1); MV.resize(m*3,1);
    MI.block(0*m,0,m,1) = F.col(0);
    MI.block(1*m,0,m,1) = F.col(1);
    MI.block(2*m,0,m,1) = F.col(2);
    MJ = MI;

    // Holy shit this needs to be cleaned up and optimized
    Eigen::Matrix<ScalarS,Eigen::Dynamic,3> cosines(m,3);
    cosines.col(0) =
        (l.col(2).array().pow(2)+l.col(1).array().pow(2)-l.col(0).array().pow(2))/(l.col(1).array()*l.col(2).array()*2.0);
    cosines.col(1) =
        (l.col(0).array().pow(2)+l.col(2).array().pow(2)-l.col(1).array().pow(2))/(l.col(2).array()*l.col(0).array()*2.0);
    cosines.col(2) =
        (l.col(1).array().pow(2)+l.col(0).array().pow(2)-l.col(2).array().pow(2))/(l.col(0).array()*l.col(1).array()*2.0);
    Eigen::Matrix<ScalarS,Eigen::Dynamic,3> barycentric = cosines.array() * l.array();
    normalize_row_sums(barycentric,barycentric);
    Eigen::Matrix<ScalarS,Eigen::Dynamic,3> partial = barycentric;
    partial.col(0).array() *= dblA.array() * 0.5;
    partial.col(1).array() *= dblA.array() * 0.5;
    partial.col(2).array() *= dblA.array() * 0.5;
    Eigen::Matrix<ScalarS,Eigen::Dynamic,3> quads(partial.rows(),partial.cols());
    quads.col(0) = (partial.col(1)+partial.col(2))*0.5;
    quads.col(1) = (partial.col(2)+partial.col(0))*0.5;
    quads.col(2) = (partial.col(0)+partial.col(1))*0.5;

    quads.col(0) = (cosines.col(0).array()<0).select( 0.25*dblA,quads.col(0));
    quads.col(1) = (cosines.col(0).array()<0).select(0.125*dblA,quads.col(1));
    quads.col(2) = (cosines.col(0).array()<0).select(0.125*dblA,quads.col(2));

    quads.col(0) = (cosines.col(1).array()<0).select(0.125*dblA,quads.col(0));
    quads.col(1) = (cosines.col(1).array()<0).select(0.25*dblA,quads.col(1));
    quads.col(2) = (cosines.col(1).array()<0).select(0.125*dblA,quads.col(2));

    quads.col(0) = (cosines.col(2).array()<0).select(0.125*dblA,quads.col(0));
    quads.col(1) = (cosines.col(2).array()<0).select(0.125*dblA,quads.col(1));
    quads.col(2) = (cosines.col(2).array()<0).select( 0.25*dblA,quads.col(2));

    MV.block(0*m,0,m,1) = quads.col(0);
    MV.block(1*m,0,m,1) = quads.col(1);
    MV.block(2*m,0,m,1) = quads.col(2);

    sparse(MI,MJ,MV,n,n,M);
}

template <typename DerivedA, typename DerivedB>
void OpenMeshObject::normalize_row_sums(
    const Eigen::MatrixBase<DerivedA>& A,
    Eigen::MatrixBase<DerivedB> & B)
{
    B = (A.array().colwise() / A.rowwise().sum().array()).eval();
}

template <class IndexVector, class ValueVector, typename T>
void OpenMeshObject::sparse(
    const IndexVector & I,
    const IndexVector & J,
    const ValueVector & V,
    const size_t m,
    const size_t n,
    Eigen::SparseMatrix<T>& X)
{
    std::vector<Eigen::Triplet<T> > IJV;
    IJV.reserve(I.size());
    for(int x = 0;x<I.size();x++)
    {
        IJV.push_back(Eigen::Triplet<T >(I(x),J(x),V(x)));
    }
    X.resize(m,n);
    X.setFromTriplets(IJV.begin(),IJV.end());
}

template <typename T>
void OpenMeshObject::invert_diag(
    const Eigen::SparseMatrix<T>& X,
    Eigen::SparseMatrix<T>& Y)
{
    // http://www.alecjacobson.com/weblog/?p=2552
    if(&Y != &X)
    {
        Y = X;
    }
    // Iterate over outside
    for(int k=0; k<Y.outerSize(); ++k)
    {
        // Iterate over inside
        for(typename Eigen::SparseMatrix<T>::InnerIterator it (Y,k); it; ++it)
        {
            if(it.col() == it.row())
            {
                T v = it.value();
                //assert(v != 0);
                v = ((T)1.0)/v;
                Y.coeffRef(it.row(),it.col()) = v;
            }
        }
    }
}

template <typename T, typename Derivedknown>
bool OpenMeshObject::min_quad_with_fixed_precompute(
    const Eigen::SparseMatrix<T>& A2,
    const Eigen::PlainObjectBase<Derivedknown> & known,
    const Eigen::SparseMatrix<T>& Aeq,
    const bool pd,
    min_quad_with_fixed_data<T> & data)
{
    const Eigen::SparseMatrix<T> A = 0.5*A2;
    // number of rows
    int n = A.rows();
    // cache problem size
    data.n = n;

    int neq = Aeq.rows();
    // number of known rows
    int kr = known.size();

    // cache known
    data.known = known;
    // get list of unknown indices
    data.unknown.resize(n-kr);
    std::vector<bool> unknown_mask;
    unknown_mask.resize(n,true);
    for(int i = 0;i<kr;i++)
    {
        unknown_mask[known(i)] = false;
    }
    int u = 0;
    for(int i = 0;i<n;i++)
    {
        if(unknown_mask[i])
        {
            data.unknown(u) = i;
            u++;
        }
    }
    // get list of lagrange multiplier indices
    data.lagrange.resize(neq);
    for(int i = 0;i<neq;i++)
    {
        data.lagrange(i) = n + i;
    }
    // cache unknown followed by lagrange indices
    data.unknown_lagrange.resize(data.unknown.size()+data.lagrange.size());
    data.unknown_lagrange << data.unknown, data.lagrange;

    Eigen::SparseMatrix<T> Auu;
    slice(A,data.unknown,data.unknown,Auu);

    // Positive definiteness is *not* determined, rather it is given as a
    // parameter
    data.Auu_pd = pd;
    if(data.Auu_pd)
    {
        // PD implies symmetric
        data.Auu_sym = true;
    }

    // Determine number of linearly independent constraints
    if(neq<=0)
    {
        data.Aeq_li = true;
    }

    if(data.Aeq_li)
    {
        // Append lagrange multiplier quadratic terms
        Eigen::SparseMatrix<T> new_A;
        Eigen::SparseMatrix<T> AeqT = Aeq.transpose();
        Eigen::SparseMatrix<T> Z(neq,neq);
        // This is a bit slower. But why isn't cat fast?
        new_A = cat(1, cat(2,   A, AeqT ),
                       cat(2, Aeq,    Z ));

        // precompute RHS builders
        if(kr > 0)
        {
            Eigen::SparseMatrix<T> Aulk,Akul;
            // Slow
            slice(new_A,data.unknown_lagrange,data.known,Aulk);
            //// This doesn't work!!!
            //data.preY = Aulk + Akul.transpose();
            // Slow
            if(data.Auu_sym)
            {
                data.preY = Aulk*2;
            }
        }

        // Positive definite and no equality constraints (Postive definiteness
        // implies symmetric)
        if(data.Auu_pd && neq == 0)
        {
            data.llt.compute(Auu);
            switch(data.llt.info())
            {
            case Eigen::Success:
                break;
            case Eigen::NumericalIssue:
                std::cerr<<"Error: Numerical issue."<<std::endl;
                return false;
            default:
                std::cerr<<"Error: Other."<<std::endl;
                return false;
            }
            data.solver_type = min_quad_with_fixed_data<T>::LLT;
        }
    }
    return true;
}

template <typename T, typename DerivedB, typename DerivedY, typename DerivedBeq, typename DerivedZ, typename Derivedsol>
bool OpenMeshObject::min_quad_with_fixed_solve(
    const min_quad_with_fixed_data<T> & data,
    const Eigen::PlainObjectBase<DerivedB> & B,
    const Eigen::PlainObjectBase<DerivedY> & Y,
    const Eigen::PlainObjectBase<DerivedBeq> & Beq,
    Eigen::PlainObjectBase<DerivedZ> & Z,
    Eigen::PlainObjectBase<Derivedsol> & sol)
{
    typedef Eigen::Matrix<T,Eigen::Dynamic,1> VectorXT;
    typedef Eigen::Matrix<T,Eigen::Dynamic,Eigen::Dynamic> MatrixXT;
    // number of known rows
    int kr = data.known.size();
    // number of columns to solve
    int cols = Y.cols();

    // resize output
    Z.resize(data.n,cols);
    // Set known values
    for(int i = 0;i < kr;i++)
    {
        for(int j = 0;j < cols;j++)
        {
            Z(data.known(i),j) = Y(i,j);
        }
    }

    if(data.Aeq_li)
    {
        // number of lagrange multipliers aka linear equality constraints
        int neq = data.lagrange.size();
        // append lagrange multiplier rhs's
        VectorXT BBeq(B.size() + Beq.size());
        BBeq << B, (Beq*-2.0);
        // Build right hand side
        VectorXT BBequl;
        slice(BBeq,data.unknown_lagrange,BBequl);
        MatrixXT BBequlcols;
        repmat(BBequl,1,cols,BBequlcols);
        MatrixXT NB;
        if(kr == 0)
        {
            NB = BBequlcols;
        }else
        {
            NB = data.preY * Y + BBequlcols;
        }

        //std::cout<<"NB=["<<std::endl<<NB<<std::endl<<"];"<<std::endl;
        //cout<<matlab_format(NB,"NB")<<endl;
        switch(data.solver_type)
        {
        case OpenMeshObject::min_quad_with_fixed_data<T>::LLT:
            sol = data.llt.solve(NB);
            break;
        default:
            std::cerr<<"Error: invalid solver type"<<std::endl;
            return false;
        }
        //std::cout<<"sol=["<<std::endl<<sol<<std::endl<<"];"<<std::endl;
        // Now sol contains sol/-0.5
        sol *= -0.5;
        // Now sol contains solution
        // Place solution in Z
        for(int i = 0;i<(sol.rows()-neq);i++)
        {
            for(int j = 0;j<sol.cols();j++)
            {
                Z(data.unknown_lagrange(i),j) = sol(i,j);
            }
        }
    }
    return true;
}

template <typename T, typename DerivedB, typename DerivedY, typename DerivedBeq, typename DerivedZ>
bool OpenMeshObject::min_quad_with_fixed_solve(
    const min_quad_with_fixed_data<T> & data,
    const Eigen::PlainObjectBase<DerivedB> & B,
    const Eigen::PlainObjectBase<DerivedY> & Y,
    const Eigen::PlainObjectBase<DerivedBeq> & Beq,
    Eigen::PlainObjectBase<DerivedZ> & Z)
{
    Eigen::PlainObjectBase<DerivedZ> sol;
    return min_quad_with_fixed_solve(data,B,Y,Beq,Z,sol);
}

template <typename T>
void OpenMeshObject::slice(
    const Eigen::SparseMatrix<T>& X,
    const Eigen::Matrix<int,Eigen::Dynamic,1> & R,
    const Eigen::Matrix<int,Eigen::Dynamic,1> & C,
    Eigen::SparseMatrix<T>& Y)
{
    int xm = X.rows();
    int xn = X.cols();
    int ym = R.size();
    int yn = C.size();

    // special case when R or C is empty
    if(ym == 0 || yn == 0)
    {
        Y.resize(ym,yn);
        return;
    }

    // Build reindexing maps for columns and rows, -1 means not in map
    std::vector< std::vector<int> > RI;
    RI.resize(xm);
    for(int i = 0;i<ym;i++)
    {
        RI[R(i)].push_back(i);
    }
    std::vector< std::vector<int> > CI;
    CI.resize(xn);
    // initialize to -1
    for(int i = 0;i<yn;i++)
    {
        CI[C(i)].push_back(i);
    }
    // Resize output
    Eigen::DynamicSparseMatrix<T, Eigen::RowMajor> dyn_Y(ym,yn);
    // Take a guess at the number of nonzeros (this assumes uniform distribution
    // not banded or heavily diagonal)
    dyn_Y.reserve((X.nonZeros()/(X.rows()*X.cols())) * (ym*yn));
    // Iterate over outside
    for(int k=0; k<X.outerSize(); ++k)
    {
        // Iterate over inside
        for(typename Eigen::SparseMatrix<T>::InnerIterator it (X,k); it; ++it)
        {
            std::vector<int>::iterator rit, cit;
            for(rit = RI[it.row()].begin();rit != RI[it.row()].end(); rit++)
            {
                for(cit = CI[it.col()].begin();cit != CI[it.col()].end(); cit++)
                {
                    dyn_Y.coeffRef(*rit,*cit) = it.value();
                }
            }
        }
    }
    Y = Eigen::SparseMatrix<T>(dyn_Y);
}

template <typename DerivedX>
void OpenMeshObject::slice(
    const Eigen::PlainObjectBase<DerivedX> & X,
    const Eigen::Matrix<int,Eigen::Dynamic,1> & R,
    const Eigen::Matrix<int,Eigen::Dynamic,1> & C,
    Eigen::PlainObjectBase<DerivedX> & Y)
{
    int ym = R.size();
    int yn = C.size();

    // special case when R or C is empty
    if(ym == 0 || yn == 0)
    {
        Y.resize(ym,yn);
        return;
    }

    // Resize output
    Y.resize(ym,yn);
    // loop over output rows, then columns
    for(int i = 0;i<ym;i++)
    {
        for(int j = 0;j<yn;j++)
        {
            Y(i,j) = X(R(i),C(j));
        }
    }
}

template <typename DerivedX>
void OpenMeshObject::slice(
    const Eigen::PlainObjectBase<DerivedX> & X,
    const Eigen::Matrix<int,Eigen::Dynamic,1> & R,
    Eigen::PlainObjectBase<DerivedX> & Y)
{
    // phony column indices
    Eigen::Matrix<int,Eigen::Dynamic,1> C;
    C.resize(1);
    C(0) = 0;
    return slice(X,R,C,Y);
}

// Sparse matrices need to be handled carefully. Because C++ does not
// Template:
//   Scalar  sparse matrix scalar type, e.g. double
template <typename ScalarS>
void OpenMeshObject::cat(
    const int dim,
    const Eigen::SparseMatrix<ScalarS> & A,
    const Eigen::SparseMatrix<ScalarS> & B,
    Eigen::SparseMatrix<ScalarS> & C)
{
    // Special case if B or A is empty
    if(A.size() == 0)
    {
        C = B;
        return;
    }
    if(B.size() == 0)
    {
        C = A;
        return;
    }

    Eigen::DynamicSparseMatrix<ScalarS, Eigen::RowMajor> dyn_C;
    if(dim == 1)
    {
        dyn_C.resize(A.rows()+B.rows(),A.cols());
    }else if(dim == 2)
    {
        dyn_C.resize(A.rows(),A.cols()+B.cols());
    }else
    {
        fprintf(stderr,"cat.h: Error: Unsupported dimension %d\n",dim);
    }

    dyn_C.reserve(A.nonZeros()+B.nonZeros());

    // Iterate over outside of A
    for(int k=0; k<A.outerSize(); ++k)
    {
        // Iterate over inside
        for(typename Eigen::SparseMatrix<ScalarS>::InnerIterator it (A,k); it; ++it)
        {
            dyn_C.coeffRef(it.row(),it.col()) += it.value();
        }
    }

    // Iterate over outside of B
    for(int k=0; k<B.outerSize(); ++k)
    {
        // Iterate over inside
        for(typename Eigen::SparseMatrix<ScalarS>::InnerIterator it (B,k); it; ++it)
        {
            int r = (dim == 1 ? A.rows()+it.row() : it.row());
            int c = (dim == 2 ? A.cols()+it.col() : it.col());
            dyn_C.coeffRef(r,c) += it.value();
        }
    }

    C = Eigen::SparseMatrix<ScalarS>(dyn_C);
}

template <class Mat>
Mat OpenMeshObject::cat(const int dim, const Mat & A, const Mat & B)
{
    Mat C;
    cat(dim,A,B,C);
    return C;
}

template <typename DerivedA, typename DerivedB>
void OpenMeshObject::repmat(
    const Eigen::PlainObjectBase<DerivedA> & A,
    const int r,
    const int c,
    Eigen::PlainObjectBase<DerivedB> & B)
{
    // Make room for output
    B.resize(r*A.rows(),c*A.cols());

    // copy tiled blocks
    for(int i = 0;i<r;i++)
    {
        for(int j = 0;j<c;j++)
        {
            B.block(i*A.rows(),j*A.cols(),A.rows(),A.cols()) = A;
        }
    }
}
